[databases]
db1 = host=1.1.1.1 port=5432 dbname=db1 user=db1_user
db2 = host=1.1.1.1 port=5432 dbname=db2 user=db2_user

[pgbouncer]
listen_addr = 1.1.1.1
listen_port = 3333
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt
admin_users = admin_user
pool_mode = transaction
max_client_conn = 1000
default_pool_size = 20
logfile = /var/log/pgbouncer/pgbouncer.log
pidfile = /var/log/pgbouncer/pgbouncer.pid
unix_socket_dir = /tmp
ignore_startup_parameters = extra_float_digits


====================================
WITH SchemaSize AS (
  SELECT 
    ps.nspname AS schema_name,
    SUM(pg_total_relation_size(pc.oid)) AS total_size
  FROM 
    pg_class pc
  JOIN 
    pg_catalog.pg_namespace ps ON ps.oid = pc.relnamespace
  GROUP BY 
    ps.nspname
)
SELECT 
  ss.schema_name,
  pg_size_pretty(ss.total_size) AS total_size_pretty
FROM 
  SchemaSize ss
ORDER BY 
  ss.total_size DESC
LIMIT 10;


======================


Triggers on Distributed Tables
Citus does not yet support creating triggers on distributed tables. As a workaround you can manually create triggers on table shards directly on the worker nodes. This works differently in different scenarios.

Trigger between colocated tables.

When two distributed tables are colocated, then we can create a trigger to modify one based on changes in the other. The idea, once again, is to create triggers on the placements, but the trigger must be between pairs of placements that are themselves colocated. For this Citus has a special helper function run_command_on_colocated_placements.

Suppose that for every value inserted into little_vals we want to insert one twice as big into big_vals.

CREATE TABLE little_vals (key int, val int);
CREATE TABLE big_vals    (key int, val int);
SELECT create_distributed_table('little_vals', 'key');
SELECT create_distributed_table('big_vals',    'key');

-- This trigger function takes the destination placement as an argument

SELECT run_command_on_workers($cmd$
  CREATE OR REPLACE FUNCTION embiggen() RETURNS TRIGGER AS $$
    BEGIN
      IF (TG_OP = 'INSERT') THEN
        EXECUTE format(
          'INSERT INTO %s (key, val) SELECT ($1).key, ($1).val*2;',
          TG_ARGV[0]
        ) USING NEW;
      END IF;
      RETURN NULL;
    END;
  $$ LANGUAGE plpgsql;
$cmd$);

-- Next we relate the co-located tables by the trigger function
-- on each co-located placement

SELECT run_command_on_colocated_placements(
  'little_vals',
  'big_vals',
  $cmd$
    CREATE TRIGGER after_insert AFTER INSERT ON %s
      FOR EACH ROW EXECUTE PROCEDURE embiggen(%s)
  $cmd$
);

/opt/app/postgres-data/data/log/
 
but if i remember correctly, postgresql will complain if the permissions are not 600 for that folder, right?
 

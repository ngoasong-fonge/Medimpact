[databases]
db1 = host=1.1.1.1 port=5432 dbname=db1 user=db1_user
db2 = host=1.1.1.1 port=5432 dbname=db2 user=db2_user

[pgbouncer]
listen_addr = 1.1.1.1
listen_port = 3333
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt
admin_users = admin_user
pool_mode = transaction
max_client_conn = 1000
default_pool_size = 20
logfile = /var/log/pgbouncer/pgbouncer.log
pidfile = /var/log/pgbouncer/pgbouncer.pid
unix_socket_dir = /tmp
ignore_startup_parameters = extra_float_digits


====================================


psql 'host=10.13.102.119 user=repmgr dbname=repmgr connect_timeout=2'

==================================


Solution 1 (By managing temporary directory /run/postgresql, /var/run/postgresql)

Directory /run/postgresql is a temporary directory. Path /var/run/postgresql is usually a symbolic link to /run/postgresql.

systemd-tmpfiles is mechanism to manage such temporary files and directories. systemd-tmpfiles creates temporary directories during boot and sets their owner, group and permissions. It may read configuration files in three different locations. Files in /etc/tmpfiles.d override files with the same name in /usr/lib/tmpfiles.d and /run/tmpfiles.d.

We can create directory /run/postgresql on the fly at boot time using systemd-tmpfiles mechanism by creating postgresql configuration file as below

echo "d /run/postgresql 0755 postgres postgres -" > /usr/lib/tmpfiles.d/postgresql.conf
Solution 2 (By relocating PostgreSQL lock file location)

Another way to fix the issue is to relocate the PostgreSQL lock file location. We can do so by using below query

ALTER SYSTEM SET unix_socket_directories='<any-existing-path-with-valid-permissions>, /tmp';
Here we can provide any path for PostgreSQL lock file which is already present on the system and have required permissions to manage lock files by postgres user.


https://www.postgresql.org/developer/roadmap/

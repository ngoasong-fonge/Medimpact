[databases]
db1 = host=1.1.1.1 port=5432 dbname=db1 user=db1_user
db2 = host=1.1.1.1 port=5432 dbname=db2 user=db2_user

[pgbouncer]
listen_addr = 1.1.1.1
listen_port = 3333
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt
admin_users = admin_user
pool_mode = transaction
max_client_conn = 1000
default_pool_size = 20
logfile = /var/log/pgbouncer/pgbouncer.log
pidfile = /var/log/pgbouncer/pgbouncer.pid
unix_socket_dir = /tmp
ignore_startup_parameters = extra_float_digits


====================================
WITH SchemaSize AS (
  SELECT 
    ps.nspname AS schema_name,
    SUM(pg_total_relation_size(pc.oid)) AS total_size
  FROM 
    pg_class pc
  JOIN 
    pg_catalog.pg_namespace ps ON ps.oid = pc.relnamespace
  GROUP BY 
    ps.nspname
)
SELECT 
  ss.schema_name,
  pg_size_pretty(ss.total_size) AS total_size_pretty
FROM 
  SchemaSize ss
ORDER BY 
  ss.total_size DESC
LIMIT 10;


======================


-- Create a function to check if a role exists
CREATE FUNCTION pg_temp.role_exists(role_name TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN (
        SELECT COUNT(*) = 1
        FROM pg_roles
        WHERE rolname = role_name
    );
END
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create cluster-wide roles if they do not exist yet
DO $$
BEGIN
    IF NOT pg_temp.role_exists('pgaudit_owner') THEN
        CREATE ROLE pgaudit_owner;
    END IF;

    IF NOT pg_temp.role_exists('pgaudit_etl') THEN
        CREATE ROLE pgaudit_etl;
    END IF;

    IF NOT pg_temp.role_exists('pgaudit') THEN
        CREATE USER pgaudit IN ROLE pgaudit_etl;

        -- Disable audit logging for the pgaudit user
        ALTER ROLE pgaudit SET pgaudit.log = 'none';
        ALTER ROLE pgaudit SET pgaudit.role = '';
    END IF;
END $$;

-- Create pgaudit schema
CREATE SCHEMA pgaudit AUTHORIZATION pgaudit_owner;

-- Set session authorization so all schema objects are owned by pgaudit_owner
SET SESSION AUTHORIZATION pgaudit_owner;

-- Create usage on schema to public
GRANT USAGE ON SCHEMA pgaudit TO PUBLIC;

-- Create session table to track user database sessions
CREATE TABLE pgaudit.session (
    session_id TEXT NOT NULL,
    process_id INT NOT NULL,
    session_start_time TIMESTAMP WITH TIME ZONE NOT NULL,
    user_name TEXT NOT NULL,
    application_name TEXT,
    connection_from TEXT,
    state TEXT NOT NULL CONSTRAINT session_state_ck CHECK (state IN ('ok', 'error')),
    CONSTRAINT session_pk PRIMARY KEY (session_id)
);

-- Distribute the pgaudit.session table in Citus
SELECT create_distributed_table('pgaudit.session', 'session_id');

GRANT SELECT, INSERT, UPDATE (application_name) ON pgaudit.session TO pgaudit_etl;

-- Create logon table to track recent user login info
CREATE TABLE pgaudit.logon (
    user_name TEXT NOT NULL,
    last_success TIMESTAMP WITH TIME ZONE,
    current_success TIMESTAMP WITH TIME ZONE,
    last_failure TIMESTAMP WITH TIME ZONE,
    failures_since_last_success INT NOT NULL,
    CONSTRAINT logon_pk PRIMARY KEY (user_name)
);

-- Distribute the pgaudit.logon table in Citus
SELECT create_distributed_table('pgaudit.logon', 'user_name');

GRANT SELECT, INSERT (user_name, current_success, last_failure, failures_since_last_success),
       UPDATE (last_success, current_success, last_failure, failures_since_last_success) ON pgaudit.logon TO pgaudit_etl;

-- Create logon_info() function to allow unprivileged users to get (only) their logon info
CREATE OR REPLACE FUNCTION pgaudit.logon_info()
RETURNS TABLE (
    last_success TIMESTAMP WITH TIME ZONE,
    last_failure TIMESTAMP WITH TIME ZONE,
    failures_since_last_success INT
) AS $$
BEGIN
    RETURN QUERY (
        SELECT logon.last_success, logon.last_failure, logon.failures_since_last_success
        FROM pgaudit.logon
        WHERE logon.user_name = session_user
    );
END
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION pgaudit.logon_info() TO PUBLIC;

-- Create log_event table to track all events logged to the PostgreSQL log
CREATE TABLE pgaudit.log_event (
    session_id TEXT NOT NULL CONSTRAINT logevent_sessionid_fk REFERENCES pgaudit.session (session_id),
    session_line_num NUMERIC NOT NULL,
    log_time TIMESTAMP(3) WITH TIME ZONE NOT NULL,
    command TEXT,
    error_severity TEXT,
    sql_state_code TEXT,
    virtual_transaction_id TEXT,
    transaction_id BIGINT,
    message TEXT,
    detail TEXT,
    hint TEXT,
    query TEXT,
    query_pos INTEGER,
    internal_query TEXT,
    internal_query_pos INTEGER,
    context TEXT,
    location TEXT,
    CONSTRAINT logevent_pk PRIMARY KEY (session_id, session_line_num)
);

-- Distribute the pgaudit.log_event table in Citus
SELECT create_distributed_table('pgaudit.log_event', 'session_id');

GRANT SELECT, INSERT ON pgaudit.log_event TO pgaudit_etl;

-- Create audit_statement table to track all user statements logged by the pgaudit extension
CREATE TABLE pgaudit.audit_statement (
    session_id TEXT NOT NULL CONSTRAINT auditstatement_sessionid_fk REFERENCES pgaudit.session (session_id),
    statement_id NUMERIC NOT NULL,
    state TEXT NOT NULL DEFAULT 'ok' CONSTRAINT auditstatement_state_ck CHECK (state IN ('ok', 'error')),
    error_session_line_num NUMERIC,
    CONSTRAINT auditstatement_pk PRIMARY KEY (session_id, statement_id),
    CONSTRAINT auditstatement_sessionid_sessionlinenum_fk FOREIGN KEY (session_id, error_session_line_num)
    REFERENCES pgaudit.log_event (session_id, session_line_num) DEFERRABLE INITIALLY DEFERRED
);

-- Distribute the pgaudit.audit_statement table in Citus
SELECT create_distributed_table('pgaudit.audit_statement', 'session_id');

GRANT SELECT, UPDATE (state, error_session_line_num), INSERT ON pgaudit.audit_statement TO pgaudit_etl;

-- Create audit_substatement table to track all user sub-statements logged by the pgaudit extension
CREATE TABLE pgaudit.audit_substatement (
    session_id TEXT NOT NULL,
    statement_id NUMERIC NOT NULL,
    substatement_id NUMERIC NOT NULL,
    substatement TEXT,
    parameter TEXT[],
    CONSTRAINT auditsubstatement_pk PRIMARY KEY (session_id, statement_id, substatement_id),
    CONSTRAINT auditsubstatement_sessionid_statementid_fk FOREIGN KEY (session_id, statement_id)
    REFERENCES pgaudit.audit_statement (session_id, statement_id)
);

-- Distribute the pgaudit.audit_substatement table in Citus
SELECT create_distributed_table('pgaudit.audit_substatement', 'session_id');

GRANT SELECT, INSERT ON pgaudit.audit_substatement TO pgaudit_etl;

-- Create audit_substatement_detail table to track all user sub-statement detail logged by the pgaudit extension
CREATE TABLE pgaudit.audit_substatement_detail (
    session_id TEXT NOT NULL,
    statement_id NUMERIC NOT NULL,
    substatement_id NUMERIC NOT NULL,
    session_line_num NUMERIC NOT NULL,
    audit_type TEXT NOT NULL CONSTRAINT auditsubstatementdetail_audittype_ck CHECK (audit_type IN ('session', 'object')),
    class TEXT NOT NULL,
    command TEXT NOT NULL,
    object_type TEXT,
    object_name TEXT,
    CONSTRAINT auditsubstatementdetail_pk PRIMARY KEY (session_id, statement_id, substatement_id, session_line_num),
    CONSTRAINT auditsubstatementdetail_sessionid_sessionlinenum_unq UNIQUE (session_id, session_line_num),
    CONSTRAINT auditsubstatementdetail_sessionid_statementid_substatementid_fk FOREIGN KEY (session_id, statement_id, substatement_id)
    REFERENCES pgaudit.audit_substatement (session_id, statement_id, substatement_id),
    CONSTRAINT auditsubstatementdetail_sessionid_sessionlinenum_fk FOREIGN KEY (session_id, session_line_num)
    REFERENCES pgaudit.log_event (session_id, session_line_num) DEFERRABLE INITIALLY DEFERRED
);

-- Distribute the pgaudit.audit_substatement_detail table in Citus
SELECT create_distributed_table('pgaudit.audit_substatement_detail', 'session_id');

GRANT SELECT, INSERT ON pgaudit.audit_substatement_detail TO pgaudit_etl;

-- Create vw_audit_event view to allow easy access to the pgaudit log entries
CREATE VIEW pgaudit.vw_audit_event AS
SELECT 
    session.session_id,
    log_event.session_line_num,
    log_event.log_time,
    session.user_name,
    audit_statement.statement_id,
    audit_statement.state,
    audit_statement.error_session_line_num,
    audit_substatement.substatement_id,
    audit_substatement.substatement,
    audit_substatement_detail.audit_type,
    audit_substatement_detail.class,
    audit_substatement_detail.command,
    audit_substatement_detail.object_type,
    audit_substatement_detail.object_name
FROM 
    pgaudit.audit_substatement_detail
    INNER JOIN pgaudit.log_event ON log_event.session_id = audit_substatement_detail.session_id
    AND log_event.session_line_num = audit_substatement_detail.session_line_num
    INNER JOIN pgaudit.session ON session.session_id = audit_substatement_detail.session_id
    INNER JOIN pgaudit.audit_substatement ON audit_substatement.session_id = audit_substatement_detail.session_id
    AND audit_substatement.statement_id = audit_substatement_detail.statement_id
    AND audit_substatement.substatement_id = audit_substatement_detail.substatement_id
    INNER JOIN pgaudit.audit_statement ON audit_statement.session_id = audit_substatement_detail.session_id
    AND audit_statement.statement_id = audit_substatement_detail.statement_id;

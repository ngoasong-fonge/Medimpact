Enabling the pg_partman extension

If you have multiple databases inside the same PostgreSQL DB instance for which you want to manage partitions, enable the pg_partman extension separately for each database. 
To enable the pg_partman extension for a specific database, create the partition maintenance schema and then create the pg_partman extension as follows

CREATE SCHEMA partman;
CREATE EXTENSION pg_partman WITH SCHEMA partman;


For the examples that show using the pg_partman extension, we use the following sample database table and partition. This database uses a partitioned table based on a timestamp.
A schema data_mart contains a table named events with a column named created_at. The following settings are included in the events table:

Primary keys event_id and created_at, which must have the column used to guide the partition.

A check constraint ck_valid_operation to enforce values for an operation table column.

Two foreign keys, where one (fk_orga_membership) points to the external table organization and the other (fk_parent_event_id) is a self-referenced foreign key.

Two indexes, where one (idx_org_id) is for the foreign key and the other (idx_event_type) is for the event type.

The following DDL statements create these objects, which are automatically included on each partition.



CREATE SCHEMA data_mart;
CREATE TABLE data_mart.organization ( org_id BIGSERIAL,
        org_name TEXT,
        CONSTRAINT pk_organization PRIMARY KEY (org_id)  
    );

CREATE TABLE data_mart.events(
        event_id        BIGSERIAL, 
        operation       CHAR(1), 
        value           FLOAT(24), 
        parent_event_id BIGINT, 
        event_type      VARCHAR(25), 
        org_id          BIGSERIAL, 
        created_at      timestamp, 
        CONSTRAINT pk_data_mart_event PRIMARY KEY (event_id, created_at), 
        CONSTRAINT ck_valid_operation CHECK (operation = 'C' OR operation = 'D'), 
        CONSTRAINT fk_orga_membership 
            FOREIGN KEY(org_id) 
            REFERENCES data_mart.organization (org_id),
        CONSTRAINT fk_parent_event_id 
            FOREIGN KEY(parent_event_id, created_at) 
            REFERENCES data_mart.events (event_id,created_at)
    ) PARTITION BY RANGE (created_at);

CREATE INDEX idx_org_id     ON  data_mart.events(org_id);
CREATE INDEX idx_event_type ON  data_mart.events(event_type);



Configuring partitions using the create_parent function

SELECT partman.create_parent( p_parent_table => 'data_mart.events',
 p_control => 'created_at',
 p_type => 'native',
 p_interval=> 'daily',
 p_premake => 30);

 The parameters are as follows:

p_parent_table – The parent partitioned table. This table must already exist and be fully qualified, including the schema.

p_control – The column on which the partitioning is to be based. The data type must be an integer or time-based.

p_type – The type is either 'native' or 'partman'. You typically use the native type for its performance improvements and flexibility. The partman type relies on inheritance.

p_interval – The time interval or integer range for each partition. Example values include daily, hourly, and so on.

p_premake – The number of partitions to create in advance to support new inserts.



Configuring partition maintenance using the run_maintenance_proc function

CREATE EXTENSION pg_cron;

UPDATE partman.part_config 
SET infinite_time_partitions = true,
    retention = '3 months', 
    retention_keep_table=true 
WHERE parent_table = 'data_mart.events';
SELECT cron.schedule('@hourly', $$CALL partman.run_maintenance_proc()$$);



Following, you can find a step-by-step explanation of the preceding example:

Modify the parameter group associated with your DB instance and add pg_cron to the shared_preload_libraries parameter value. This change requires a DB instance restart for it to take effect. For more information, see Modifying parameters in a DB parameter group.

Run the command CREATE EXTENSION pg_cron; using an account that has the rds_superuser permissions. Doing this enables the pg_cron extension. For more information, see Scheduling maintenance with the PostgreSQL pg_cron extension.

Run the command UPDATE partman.part_config to adjust the pg_partman settings for the data_mart.events table.

Run the command SET . . . to configure the data_mart.events table, with these clauses:

infinite_time_partitions = true, – Configures the table to be able to automatically create new partitions without any limit.

retention = '3 months', – Configures the table to have a maximum retention of three months.

retention_keep_table=true – Configures the table so that when the retention period is due, the table isn't deleted automatically. Instead, partitions that are older than the retention period are only detached from the parent table.

Run the command SELECT cron.schedule . . . to make a pg_cron function call. This call defines how often the scheduler runs the pg_partman maintenance procedure, partman.run_maintenance_proc. For this example, the procedure runs every hour.
In My case I will use crontab in linux to schedule the partman.run_maintenance_proc function

* * * * * psql -h your_postgresql_host -U your_postgresql_user -d your_database_name -c "CALL partman.run_maintenance_proc();"

--------------------------------------------------------bellow will drop table from backup schema-------------------------------------------------------------------------------------------------------------------------------


#!/bin/bash

# Source the environment file
source /opt/app/localhome/postgres/pg_env.sh

# Retention period (in weeks)
RETENTION_PERIOD=6

# Calculate the date threshold for retention
THRESHOLD_DATE=$(date -d "-$RETENTION_PERIOD weeks" "+%Y-%m-%d %H:%M:%S")

# Build the SQL query to drop old partitions
SQL_QUERY="DO \$\$
BEGIN
   EXECUTE (
      SELECT 'DROP TABLE IF EXISTS archive_schema.' || table_name || ' CASCADE'
      FROM information_schema.tables
      WHERE table_schema = 'archive_schema'
      AND table_name LIKE 'your_prefix_%' -- You can customize this prefix
      AND create_date < '$THRESHOLD_DATE'
   );
END
\$\$;"

# Execute the SQL query using psql with the specified database and retention_schema
psql -h $PG_HOST -p $PG_PORT -d citus -U $PG_USER -c "$SQL_QUERY" -v retention_schema='mepstg_archive'

# Check for errors
if [ $? -eq 0 ]; then
  echo "Dropped archived partitions older than $RETENTION_PERIOD weeks."
else
  echo "Error: Failed to drop partitions."
fi
-------------------------------------------------------------------prefared option script---------------------------------------------------------

#!/bin/bash

# Source the environment file
source /opt/app/localhome/postgres/pg_env.sh

# Retention period (in weeks)
RETENTION_PERIOD=6

# Calculate the date threshold for retention
THRESHOLD_DATE=$(date -d "-$RETENTION_PERIOD weeks" "+%Y-%m-%d %H:%M:%S")

# Build the SQL query to drop old partitions in the archive_schema
SQL_QUERY="DO \$\$
BEGIN
   EXECUTE (
      SELECT 'DROP TABLE IF EXISTS archive_schema.' || table_name || ' CASCADE'
      FROM information_schema.tables
      WHERE table_schema = 'archive_schema'
      AND create_date < '$THRESHOLD_DATE'
   );
END
\$\$;"

# Execute the SQL query using psql with the specified database
psql -h localhost -d citus -U deployadmin -c "$SQL_QUERY"

# Check for errors
if [ $? -eq 0 ]; then
  echo "Dropped archived partitions older than $RETENTION_PERIOD weeks."
else
  echo "Error: Failed to drop partitions."
fi

-----------------------------------------------------------------------bellow is checking how long copy data will take from table to table----------------------------------
Create a shell script (e.g., run_query.sh) with bellow


#!/bin/bash

# Start time
start_time=$(date +"%Y-%m-%d %H:%M:%S")

# Run the query using psql
psql -h your_host -U your_username -d your_database -c "INSERT INTO new_table SELECT * FROM old_table;"

# End time
end_time=$(date +"%Y-%m-%d %H:%M:%S")

# Print start and end time
echo "Start Time: $start_time"
echo "End Time: $end_time"

chmod +x run_query.sh


./run_query.sh > query_output.txt
nohup /opt/app/patroni/scripts/run_query.sh > run_schema_1118.log 2>&1 &

----------------------------------------

It seems you want to drop child tables older than a certain retention period and move them to an archive_schema. However, PostgreSQL doesn't natively track the creation date of tables, and the information_schema.tables doesn't contain a create_date column. Therefore, you need to handle the creation date tracking yourself, possibly by adding a column to the tables or maintaining a separate tracking mechanism.

Assuming you have a column named created_at that records the creation timestamp of each table, here's how you can adjust the SQL query:


---------------------------------------------------------------------------------------------------------


#!/bin/bash

# Source the environment file
source /opt/app/localhome/postgres/pg_env.sh

# Retention period (in weeks)
RETENTION_PERIOD=4

# Calculate the date threshold for retention
THRESHOLD_DATE=$(date -d "-$RETENTION_PERIOD weeks" "+%Y-%m-%d %H:%M:%S")

# SQL query to drop tables older than the retention period
SQL_QUERY="DO \$\$
BEGIN
   EXECUTE (
      SELECT 'DROP TABLE IF EXISTS archive_schema.' || table_name || ' CASCADE'
      FROM information_schema.tables
      WHERE table_schema = 'archive_schema'
      AND (created_at < '$THRESHOLD_DATE' OR entered_at < '$THRESHOLD_DATE') -- Adjust column names as per your schema
   );
END
\$\$;"

# Execute the SQL query using psql with the specified database
psql -h "$PG_HOST" -p "$PG_PORT" -d citus -U "$PG_USER" -c "$SQL_QUERY"

# Check for errors
if [ $? -eq 0 ]; then
  echo "Dropped tables older than $RETENTION_PERIOD weeks."
else
  echo "Error: Failed to drop tables."
fi

---------------------------------------------------------------------------------------

#!/bin/bash

# Source the environment file
source /opt/app/localhome/postgres/pg_env.sh

# Retention period (in weeks)
RETENTION_PERIOD=4

# Calculate the date threshold for retention
THRESHOLD_DATE=$(date -d "-$RETENTION_PERIOD weeks" "+%Y-%m-%d %H:%M:%S")

# SQL query to drop tables older than the retention period
SQL_QUERY="DO \$\$
BEGIN
   EXECUTE (
      SELECT 'DROP TABLE IF EXISTS archive_schema.' || table_name || ' CASCADE'
      FROM information_schema.tables
      WHERE table_schema = 'archive_schema'
      AND table_name LIKE 'your_prefix_%' -- Replace 'your_prefix_' with the prefix of your child tables
      AND (created_at < '$THRESHOLD_DATE' OR entered_at < '$THRESHOLD_DATE') -- Adjust column names as per your schema
   );
END
\$\$;"

# Execute the SQL query using psql with the specified database
psql -h "$PG_HOST" -p "$PG_PORT" -d citus -U "$PG_USER" -c "$SQL_QUERY"

# Check for errors
if [ $? -eq 0 ]; then
  echo "Dropped tables older than $RETENTION_PERIOD weeks."
else
  echo "Error: Failed to drop tables."
fi


------------------------------------------------------------------------------------------------------------------------------------------

#!/bin/bash

# PostgreSQL connection details
HOST="localhost"
PORT="5432"
USERNAME="your_username"
PASSWORD="your_password"
DATABASE="your_database"

# Schema from which to drop tables
SCHEMA="your_schema"

# Function to drop tables older than 4 weeks
drop_old_tables() {
    echo "Dropping tables older than 4 weeks from schema: $SCHEMA"

    # Get the current date and calculate the date 4 weeks ago
    CURRENT_DATE=$(date +"%Y-%m-%d")
    FOUR_WEEKS_AGO=$(date -d "-4 weeks" +"%Y-%m-%d")

    # Query to drop tables older than 4 weeks
    QUERY="
    DO \$\$
    DECLARE
        table_name RECORD;
    BEGIN
        FOR table_name IN
            SELECT table_name
            FROM information_schema.tables
            WHERE table_schema = '$SCHEMA' AND table_type = 'BASE TABLE'
        LOOP
            EXECUTE 'SELECT COUNT(*) FROM ' || table_name.table_name || ' WHERE table_name.date_column < ''' || '$FOUR_WEEKS_AGO' || '''' INTO COUNT;
            IF COUNT > 0 THEN
                EXECUTE 'DROP TABLE ' || table_name.table_name || ' CASCADE';
                RAISE NOTICE 'Dropped table: %', table_name.table_name;
            END IF;
        END LOOP;
    END
    \$\$;"

    # Execute the query
    psql -h $HOST -p $PORT -U $USERNAME -d $DATABASE -c "$QUERY"

    echo "Tables dropped successfully."
}

# Main execution
drop_old_tables


-----------------------------------------
DO $$
DECLARE
    table_name TEXT;
BEGIN
    FOR table_name IN
        SELECT tablename
        FROM pg_catalog.pg_tables
        WHERE schemaname = 'archive_schema' AND tablename LIKE 'rep_edw_log_%'
    LOOP
        RAISE NOTICE 'Table name: %', table_name;
    END LOOP;
END $$;



DO $$
DECLARE
    table_name TEXT;
BEGIN
    FOR table_name IN
        SELECT tablename
        FROM pg_catalog.pg_tables
        WHERE schemaname = 'archive_schema' AND (tablename LIKE 'rep_edw_log_%' OR tablename LIKE 'other_pattern_%')
    LOOP
        RAISE NOTICE 'Table name: %', table_name;
    END LOOP;
END $$;

---------------------------------------list and drop---------------
DO $$
DECLARE
    table_name TEXT;
BEGIN
    FOR table_name IN
        SELECT tablename
        FROM pg_catalog.pg_tables
        WHERE schemaname = 'archive_schema' AND tablename LIKE 'rep_edw_log_%'
    LOOP
        EXECUTE 'DROP TABLE IF EXISTS archive_schema.' || quote_ident(table_name) || ' CASCADE';
        RAISE NOTICE 'Dropped table: %', table_name;
    END LOOP;
END $$;


DO $$
DECLARE
    table_name TEXT;
BEGIN
    FOR table_name IN
        SELECT tablename
        FROM pg_catalog.pg_tables
        WHERE schemaname = 'archive_schema' AND (tablename LIKE 'stg_mep_claim_%' OR tablename LIKE 'rep_edw_log_%')
    LOOP
        RAISE NOTICE 'Table name: %', table_name;
        EXECUTE 'SELECT 1 FROM ' || quote_ident(table_name) || ' WHERE 
            (created < CURRENT_DATE - INTERVAL ''45 days'' AND tablename LIKE ''stg_mep_claim_%'') OR 
            (entered < CURRENT_DATE - INTERVAL ''45 days'' AND tablename LIKE ''rep_edw_log_%'') LIMIT 1' INTO table_name;
        IF FOUND THEN
            EXECUTE 'DROP TABLE IF EXISTS archive_schema.' || quote_ident(table_name) || ' CASCADE';
            RAISE NOTICE 'Dropped table: %', table_name;
        END IF;
    END LOOP;
END $$;





citus=# DO $$
citus$# DECLARE
citus$#     table_name TEXT;
        RAISE NOTICE 'Table name: %', table_name;
        EXECUTE 'SELECT 1 FROM ' || quote_ident(table_name) || ' WHERE
            (created < CURRENT_DATE - INTERVAL ''45 days'' AND tablename LIKE ''stg_mep_claim_%'') OR
citus$# BEGIN
citus$#     FOR table_name IN
citus$#         SELECT tablename
citus$#         FROM pg_catalog.pg_tables
citus$#         WHERE schemaname = 'archive_schema' AND (tablename LIKE 'stg_mep_claim_%' OR tablename LIKE 'rep_edw_log_%')
citus$#     LOOP
citus$#         RAISE NOTICE 'Table name: %', table_name;
citus$#         EXECUTE 'SELECT 1 FROM ' || quote_ident(table_name) || ' WHERE
citus$#             (created < CURRENT_DATE - INTERVAL ''45 days'' AND tablename LIKE ''stg_mep_claim_%'') OR
citus$#             (entered < CURRENT_DATE - INTERVAL ''45 days'' AND tablename LIKE ''rep_edw_log_%'') LIMIT 1' INTO table_name;
citus$#         IF FOUND THEN
citus$#             EXECUTE 'DROP TABLE IF EXISTS archive_schema.' || quote_ident(table_name) || ' CASCADE';
citus$#             RAISE NOTICE 'Dropped table: %', table_name;
citus$#         END IF;
citus$#     END LOOP;
citus$# END $$;
NOTICE:  Table name: stg_mep_claim_20r_p20230806
ERROR:  relation "stg_mep_claim_20r_p20230806" does not exist
LINE 1: SELECT 1 FROM stg_mep_claim_20r_p20230806 WHERE
                      ^
QUERY:  SELECT 1 FROM stg_mep_claim_20r_p20230806 WHERE
            (created < CURRENT_DATE - INTERVAL '45 days' AND tablename LIKE 'stg_mep_claim_%') OR
            (entered < CURRENT_DATE - INTERVAL '45 days' AND tablename LIKE 'rep_edw_log_%') LIMIT 1
CONTEXT:  PL/pgSQL function inline_code_block line 11 at EXECUTE


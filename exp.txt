Replacing T.IntegerType(), T.BooleanType(), T.DoubleType(), and T.LongType() with varchar(4000) is not ideal if the columns are intended to store numbers or booleans, as this approach sacrifices data type constraints and can lead to inconsistencies (e.g., storing non-numeric data in numeric fields). The appropriate substitutions in PostgreSQL for these data types are:

T.IntegerType() → INTEGER
T.BooleanType() → BOOLEAN
T.DoubleType() → DOUBLE PRECISION
T.LongType() → BIGINT

CREATE TABLE foundry.exposures_by_cycle_period_schema (
    id varchar(4000),
    contract_id varchar(4000),
    contract_organization_id varchar(4000),
    line_of_business varchar(4000),
    source varchar(4000),
    cycle_period_date varchar(4000),
    cycle_period_date_string varchar(4000),
    guarantee_period_id varchar(4000),
    guarantee_period_effective_date varchar(4000),
    guarantee_period_expiration_date varchar(4000),
    plan_year INTEGER,
    level varchar(4000),
    level_order INTEGER,
    level_display_string varchar(4000),
    guarantee_category_type varchar(4000),
    guarantee_category_id varchar(4000),
    guarantee_category_name varchar(4000),
    report_category_id varchar(4000),
    report_category varchar(4000),
    reporting_exclusion_id varchar(4000),
    reporting_exclusion_name varchar(4000),
    carrier_id varchar(4000),
    channel_id varchar(4000),
    channel_name varchar(4000),
    category varchar(4000),
    guarantee_type varchar(4000),
    rate_id varchar(4000),
    contract_executed BOOLEAN,
    contract_effective_date varchar(4000),
    contract_expiration_date varchar(4000),
    first_full_reconciliation_period_start_date varchar(4000),
    contract_annual_reconciliation_length DOUBLE PRECISION,
    contract_co_pay_differential DOUBLE PRECISION,
    contract_eligibility_threshold DOUBLE PRECISION,
    contract_reconciliation_period_length DOUBLE PRECISION,
    rebate_annual_reconciliation_length DOUBLE PRECISION,
    rebate_co_pay_differential DOUBLE PRECISION,
    rebate_reconciliation_period DOUBLE PRECISION,
    contract_eligibility_threshold_basis varchar(4000),
    contract_eligibility_threshold_frequency varchar(4000),
    contract_exposure_cap varchar(4000),
    contract_exposure_cap_basis varchar(4000),
    contract_exposure_offset varchar(4000),
    pharmacy_aggregation_level varchar(4000),
    pharmacy_exposure_cap varchar(4000),
    pharmacy_exposure_cap_basis varchar(4000),
    pharmacy_exposure_offset varchar(4000),
    rebate_aggregation_level varchar(4000),
    rebate_exposure_cap varchar(4000),
    rebate_exposure_cap_basis varchar(4000),
    rebate_exposure_offset varchar(4000),
    rebate_payout_period varchar(4000),
    rebate_pricing_type varchar(4000),
    has_rebate_guarantee_rates BOOLEAN,
    has_rebate_passthrough_rates BOOLEAN,
    net_rx_count BIGINT,
    admin_fee DOUBLE PRECISION,
    incremental_admin_fee DOUBLE PRECISION,
    guaranteed_exposure_exposure_cap DOUBLE PRECISION,
    guaranteed_exposure_no_cap DOUBLE PRECISION,
    guaranteed_exposure DOUBLE PRECISION,
    incremental_guaranteed_exposure DOUBLE PRECISION,
    incremental_guaranteed_exposure_exposure_cap DOUBLE PRECISION,
    incremental_guaranteed_exposure_no_cap DOUBLE PRECISION,
    incremental_net_rx_count BIGINT
);



[svcpostgres@pv2medpg3db1 foundry]$ psql -d archive -c "COPY foundry.task_edited_schema FROM '/opt/backup/foundry/task_edited_extract.csv' DELIMITER '|' CSV HEADER;"
ERROR:  missing data for column "reviewer"
CONTEXT:  COPY task_edited_schema, line 2: "c3c58eeb-5653-4afd-9ed2-7aaa4f481412,c3c58eeb-5653-4afd-9ed2-7aaa4f481412,c3c58eeb-5653-4afd-9ed2-7a..."



Using these native PostgreSQL types will help maintain data integrity and ensure that the columns store the expected data types.



To eliminate the statement: log entries and only keep the AUDIT: entries, you can adjust your PostgreSQL logging settings to stop logging SQL statements for specific users (such as auditor), or you can fine-tune the pg_audit configuration.

Option 1: Modify PostgreSQL log_statement Configuration
Disable log_statement for the auditor user: You can control the verbosity of the log entries for specific users by adjusting the log_statement setting. By default, log_statement is set to all or ddl or mod (depending on your configuration).

You can disable statement logging for the auditor user by setting log_statement to none for that user.

Setting log_statement = 'all' in PostgreSQL is a way to log every SQL statement that is executed, which is useful for auditing and tracking queries.

This setting has the following options:

none: Logs no statements.
ddl: Logs only data definition statements (like CREATE, ALTER, and DROP).
mod: Logs all DDL and data modification statements (like INSERT, UPDATE, DELETE, TRUNCATE).
all: Logs all statements, including SELECT queries.

-- create the reference tables

CREATE TABLE insert_target (
  value text
);
CREATE TABLE audit_table(
  author name NOT NULL,
  value text
);
SELECT create_reference_table('insert_target');
SELECT create_reference_table('audit_table');

To make a trigger on each worker that updates audit_table, we need to know the name of that tableâ€™s shard. Rather than looking up the name in the metadata tables and using it manually in run_command_on_workers, we can use run_command_on_placements. Reference tables have exactly one placement per worker node, so the following creates what we want.

SELECT run_command_on_placements(
  'audit_table',
  $cmd$
    CREATE OR REPLACE FUNCTION process_audit() RETURNS TRIGGER AS $$
      BEGIN
        INSERT INTO %s (author,value)
          VALUES (current_user,NEW.value);
        RETURN NEW;
      END;
    $$ LANGUAGE plpgsql;
  $cmd$
);

SELECT run_command_on_placements(
  'insert_target',
  $cmd$
    CREATE TRIGGER emp_audit
    AFTER INSERT OR UPDATE ON %s
      FOR EACH ROW EXECUTE PROCEDURE process_audit();
  $cmd$
);


[svcpostgres@pv2medpg3db1 foundry]$ cat task_edited_schema.sql
create table  task_edited_schema (
    last_modified_by varchar(4000),
    reviewer varchar(4000),
    last_status_changer varchar(4000),
    assigner varchar(4000),
    assignee varchar(4000),
    id varchar(4000),
    category varchar(4000),
    type varchar(4000),
    title varchar(4000),
    description varchar(4000),
    create table d_timestamp varchar(4000),
    priority varchar(4000),
    status varchar(4000),
    sub_status varchar(4000),
    due_date varchar(4000),
    last_status_change_timestamp varchar(4000),
    last_modified_timestamp varchar(4000),
    review_timestamp varchar(4000),
    linked_entity_id varchar(4000),
    linked_ccm_entity_id, T.IntegerType()),
    linked_entity_ids varchar(4000),
    linked_ccm_entity_ids varchar(4000)




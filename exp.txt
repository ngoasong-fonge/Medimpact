SELECT run_command_on_placements(
  'audit_table',
  $cmd$
    CREATE OR REPLACE FUNCTION process_audit() RETURNS TRIGGER AS $$
      BEGIN
        INSERT INTO %s (author,value)
          VALUES (current_user,NEW.value);
        RETURN NEW;
      END;
    $$ LANGUAGE plpgsql;
  $cmd$
);

SELECT run_command_on_placements(
  'insert_target',
  $cmd$
    CREATE TRIGGER emp_audit
    AFTER INSERT OR UPDATE ON %s
      FOR EACH ROW EXECUTE PROCEDURE process_audit();
  $cmd$
);

INSERT INTO insert_target (value) VALUES ('inserted value');

SELECT run_command_on_placements(
  'shard6.account_hist',
  $cmd$
    CREATE OR REPLACE FUNCTION shard6.tfn_account_hist() RETURNS TRIGGER AS $$
      BEGIN
        INSERT INTO %s (account_hist_id,entered, entered_by, replaced, replaced_by, account_id, client_id, account_name,
                                account_code, account_desc, account_type, status, version, effective_date)
                  VALUES (nextval('shard7.account_hist_account_hist_id_seq'),current_user, NEW.entered, NEW.entered_by, NEW.account_id, NEW.client_id, 
                NEW.account_name, NEW.account_code, NEW.account_desc, NEW.account_type, 
                NEW.status, NEW.version, NEW.effective_date);
                RETURN NEW;
      END;
    $$ LANGUAGE plpgsql;
  $cmd$
);

SELECT run_command_on_placements(
  'shard6.account',
  $cmd$
    CREATE TRIGGER trg_account_hist
    AFTER INSERT OR UPDATE OR DELETE ON %s
    FOR EACH ROW EXECUTE PROCEDURE shard7.tfn_account_hist()
  $cmd$
);

CREATE OR REPLACE FUNCTION shard6.tfn_account_hist()
RETURNS trigger
LANGUAGE plpgsql
AS $function$
              BEGIN
                INSERT INTO shard6.account_hist_102649 (account_hist_id,entered, entered_by, replaced, replaced_by, account_id, client_id, account_name,
                                account_code, account_desc, account_type, status, version, effective_date)
                  VALUES (nextval('shard7.account_hist_account_hist_id_seq'),current_user, NEW.entered, NEW.entered_by, NEW.account_id, NEW.client_id, 
                NEW.account_name, NEW.account_code, NEW.account_desc, NEW.account_type, 
                NEW.status, NEW.version, NEW.effective_date);
                RETURN NEW;
              END;
            $function$
;

INSERT INTO shard6.account ( 
    entered, 
    entered_by, 
    client_id, 
    account_name, 
    account_code, 
    account_desc, 
    account_type, 
    status, 
    version, 
    effective_date
) VALUES (
    CURRENT_TIMESTAMP,
    'test_user',
    12345,
    'Test Account',
    'TST123',
    'This is a test account description.',
    1,
    1,
    1,
    CURRENT_TIMESTAMP
);


citus=# TABLE shard6.account;
  account_id  |          entered           | entered_by | client_id | account_name | account_code |            account_desc             | account_type | status | version |       effective_date
--------------+----------------------------+------------+-----------+--------------+--------------+-------------------------------------+--------------+--------+---------+----------------------------
 100000000002 | 2024-11-05 16:01:08.552385 | test_user  |     12345 | Test Account | TST123       | This is a test account description. |            1 |      1 |       1 | 2024-11-05 16:01:08.552385
(1 row)

citus=# TABLE shard6.account_hist;
 account_hist_id | entered | entered_by | replaced | replaced_by | account_id | client_id | account_name | account_code | account_desc | account_type | status | version | effective_date
-----------------+---------+------------+----------+-------------+------------+-----------+--------------+--------------+--------------+--------------+--------+---------+----------------
(0 rows)

SELECT run_command_on_placements(
  'shard6.account',
  $cmd$
    DROP TRIGGER IF EXISTS trg_account_hist ON %s
  $cmd$
);




citus=# CREATE TABLE IF NOT EXISTS shard6.account
citus-# (
citus(#     account_id bigint NOT NULL DEFAULT nextval('shard6.account_account_id_seq'::regclass),
citus(#     entered timestamp without time zone NOT NULL DEFAULT CURRENT_TIMESTAMP,
citus(#     entered_by character varying(100) COLLATE pg_catalog."default" NOT NULL DEFAULT CURRENT_USER,
citus(#     client_id bigint NOT NULL,
citus(#     account_name character varying(1000) COLLATE pg_catalog."default" NOT NULL,
citus(#     account_code character varying(1000) COLLATE pg_catalog."default",
citus(#     account_desc character varying(9000) COLLATE pg_catalog."default",
citus(#     account_type smallint NOT NULL,
citus(#     status smallint NOT NULL,
citus(#     version integer NOT NULL,
citus(#     effective_date timestamp without time zone,
citus(#     CONSTRAINT account_pkey PRIMARY KEY (account_id),
citus(#     CONSTRAINT dfk_account_client FOREIGN KEY (client_id)
citus(#         REFERENCES smartiq.client (client_id) MATCH SIMPLE
citus(#         ON UPDATE NO ACTION
citus(#         ON DELETE NO ACTION
citus(#         DEFERRABLE INITIALLY DEFERRED
citus(# )
citus-#
citus-# TABLESPACE pg_default;
ERROR:  relation "shard6.account_account_id_seq" does not exist
LINE 3:     account_id bigint NOT NULL DEFAULT nextval('shard6.accou...
                                                       ^
citus=# CREATE SEQUENCE IF NOT EXISTS shard6.account_account_id_seq
citus-#     INCREMENT 1
citus-#     START 1
citus-#     MINVALUE 1
citus-#     MAXVALUE 9223372036854775807
citus-#     CACHE 1
citus-#     OWNED BY account.account_id;
ERROR:  relation "account" does not exist

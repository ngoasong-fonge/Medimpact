
psql:/opt/backup/ngmep_backup_2024-03-28-020001.sql:167750: error: invalid command \N
psql:/opt/backup/ngmep_backup_2024-03-28-020001.sql:167758: ERROR:  syntax error at or near "5000000001"
LINE 1: 5000000001 2023-12-02 06:48:35.947341 populate_encounter 500...

Determine the Desired Size: First, you need to decide how much memory you want to allocate to the shared_buffers parameter. In this example, you want to allocate 1GB of memory.

Convert to Kilobytes (KB): Amazon RDS for PostgreSQL uses kilobytes as the unit for the shared_buffers parameter. To convert 1GB to kilobytes, you perform the following conversions:

1 GB = 1024 MB (since 1 GB = 1024 megabytes)
1024 MB = 1024 * 1024 KB (since 1 megabyte = 1024 kilobytes)
1024 * 1024 KB = 1048576 KB
So, 1 GB is equal to 1048576 KB.

Divide by the Unit Size: The shared_buffers parameter is specified in 8KB units. To calculate the value you should set, you divide the total number of kilobytes (calculated in step 2) by the size of each unit, which is 8KB:

1048576 KB / 8 KB = 131072
So, you should set the shared_buffers parameter to 131072 in your Amazon RDS parameter group.

https://dba.stackexchange.com/questions/137297/how-to-set-up-amazon-rds-parameter-group-for-postgres

-------------------------------------------------------------------------------------------------------------

To calculate the value for the wal_buffer parameter in PostgreSQL on Amazon RDS when you want to allocate 16 MB of memory, you can use the following steps:

You want to allocate 16 MB of memory.
The unit of wal_buffer in PostgreSQL is 8 KB.
Here's how you calculate it:

16 MB = 16 * 1024 KB (1 MB = 1024 KB).

So, to allocate 16 MB of memory for the wal_buffer, you need:

(16 * 1024 KB) / 8 KB = 2048

So, you should set the wal_buffer parameter to 2048 in your RDS parameter group to allocate 16 MB of memory for the Write-Ahead Logging (WAL) buffer. 


CREATE TABLE shard.employee (
    employee_id serial ,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    department_id INT,
    created_date DATE
);


0 2 * * 6,0,1,2,3 /opt/app/patroni/scripts/pgdump_schemabackup.sh


CREATE FOREIGN TABLE dmeapps.departments_tst
(
  DEPARTMENT_ID    NUMERIC(10,0)                   NOT NULL,
  DEPARTMENT_NAME  CHARACTER VARYING(30)         NOT NULL,
  MANAGER_ID       NUMERIC(6,0),
  LOCATION_ID      NUMERIC(4,0)
) SERVER ora_sv OPTIONS (SCHEMA 'PSAMY' , TABLE 'DEPARTMENTS_TST');



-- Foreign table for PG_SVC_ACC_DETAIL
CREATE FOREIGN TABLE wsdme.pg_svc_acc_detail
(
  service_account_name  CHARACTER VARYING(200)  NOT NULL,
  db                    CHARACTER VARYING(200)  NOT NULL,
  expiry_date           DATE,
  daystogo              CHARACTER VARYING(10),
  session_cnt           NUMERIC,
  last_login            DATE,
  usename               CHARACTER VARYING(200) 
) SERVER ora_sv OPTIONS (SCHEMA 'WSDME', TABLE 'PG_SVC_ACC_DETAIL');

-- Foreign table for DBUSR
CREATE FOREIGN TABLE wsdme.dbusr
(
  dbusr_id             NUMERIC                   NOT NULL,
  username             CHARACTER VARYING(50)    NOT NULL,
  usr_type             CHARACTER VARYING(30)    NOT NULL,
  status               CHARACTER VARYING(30)    DEFAULT 'ACTIVE' NOT NULL,
  ref_task             CHARACTER VARYING(50)    NOT NULL,
  password             BYTEA,
  entered              DATE                      DEFAULT CURRENT_TIMESTAMP NOT NULL,
  entered_by           CHARACTER VARYING(30)    DEFAULT CURRENT_USER NOT NULL,
  requested_by         CHARACTER VARYING(50),
  user_comment         CHARACTER VARYING(4000),
  datical              CHARACTER(1),
  primary_db           CHARACTER VARYING(30)    NOT NULL,
  db_link              CHARACTER(1),
  vault_prefix_name    CHARACTER VARYING(60),
  orchard_exc_yn       CHARACTER(5),
  app_team             CHARACTER VARYING(30),
  app_mgr              CHARACTER VARYING(60),
  app_contact          CHARACTER VARYING(60),
  app_contact_alt      CHARACTER VARYING(60),
  intl_flag            CHARACTER VARYING(10),
  description          CHARACTER VARYING(200)   NOT NULL,
  app_name             CHARACTER VARYING(100)   NOT NULL,
  level1               CHARACTER VARYING(100)   NOT NULL,
  level2               CHARACTER VARYING(100)   NOT NULL,
  level3               CHARACTER VARYING(100)   NOT NULL,
  adhoc_needed_yn      CHARACTER(2),
  application          CHARACTER VARYING(100)
) SERVER ora_sv OPTIONS (SCHEMA 'WSDME', TABLE 'DBUSR');

-- Granting USAGE privilege on the foreign server
GRANT USAGE ON FOREIGN SERVER my_oracle_server TO my_user;

-- Granting INSERT, UPDATE, DELETE privileges on the foreign table
GRANT INSERT, UPDATE, DELETE ON my_foreign_table TO my_user;

Here is an example for a table definition that sets the key option:

CREATE FOREIGN TABLE atable (
   id    bigint OPTIONS (key 'true') NOT NULL,
   value text
) SERVER oraserver OPTIONS (table 'ATABLE');


Create single shard tables in schema tenant1 (automatically co-located)
set search_path to tenant1;
create table note_categories (
   category_id bigserial primary key,
   category_name text not null);


----------------------------------------------------------------------


It seems like you're generating SQL statements to set the autovacuum_enabled property to true for each partition of a partitioned table in PostgreSQL. Your SQL query dynamically generates these statements based on the child tables of the partitioned table.

Here's a breakdown of what the SQL query does:

It selects the child tables of the partitioned table (partitioned_table) along with their object identifiers (oid) from the PostgreSQL system catalog tables (pg_class and pg_inherits).
It constructs SQL statements using string concatenation to set the autovacuum_enabled property to true for each child table.
The pg_get_expr function is used to check if the table's partition bounds match the DEFAULT expression. This helps in ordering the results.
The gexec meta-command in the PostgreSQL client (psql) is used to execute each generated SQL statement.
This approach allows you to automate the process of enabling autovacuum for each partition of the partitioned table, which can be useful for managing vacuuming and maintenance tasks efficiently.

If you have any specific questions or need further assistance with this SQL query or related tasks, feel free to ask!


SELECT relnamespace::regnamespace AS schema_name,
       relname as table_name,
       reloptions as options
FROM pg_class
WHERE relnamespace = 'ngmep'::regnamespace 
  AND 'autovacuum_enabled=false' = ANY(
          string_to_array(array_to_string(reloptions, ','), ',')
      );

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-- Populate data for May 7, 2024 partition
INSERT INTO mepstg.tablepart (id, name, report_date)
SELECT 
    i, 
    'Name_' || i, 
    '2024-05-07'::date
FROM generate_series(1, 100) AS s(i);

-- Populate data for May 8, 2024 partition
INSERT INTO mepstg.tablepart (id, name, report_date)
SELECT 
    i + 100,  -- Ensure unique ID across partitions
    'Name_' || (i + 100),
    '2024-05-08'::date
FROM generate_series(1, 100) AS s(i);

-- Populate data for May 9, 2024 partition
INSERT INTO mepstg.tablepart (id, name, report_date)
SELECT 
    i + 200,  -- Ensure unique ID across partitions
    'Name_' || (i + 200),
    '2024-05-09'::date
FROM generate_series(1, 100) AS s(i);


----------------------------------------------------------------------------------------------------------------------------------------------------------




# tables to partition

#First rename the original table name and index
ALTER TABLE mepstg.stg_mep_claim_10r RENAME to mepstg.stg_mep_claim_10r_old;
ALTER INDEX mepstg.pk_stg_mep_claim_10r RENAME TO pk_stg_mep_claim_10r_old;
ALTER INDEX mepstg.stg_mep_claim_10r_n1 RENAME TO stg_mep_claim_10r_n1_old;
alter table mepstg.stg_mep_claim_10r_old rename constraint stg_mep_claim_10r_pkey to stg_mep_claim_10r_old_pkey; 

CREATE TABLE IF NOT EXISTS mepstg.stg_mep_claim_10r
(
    stg_mep_claim_10r_id bigint NOT NULL DEFAULT nextval('mepstg.stg_mep_claim_10r_stg_mep_claim_10r_id_seq'::regclass),
    created timestamp without time zone NOT NULL,
    created_by character varying(100) COLLATE pg_catalog."default" NOT NULL DEFAULT CURRENT_USER,
    entered timestamp without time zone NOT NULL,
    entered_by character varying(100) COLLATE pg_catalog."default" NOT NULL DEFAULT CURRENT_USER,
    stg_mep_claim_file_id bigint,
    stg_load_date date NOT NULL,
    stg_rec_status character varying(20) COLLATE pg_catalog."default",
    stg_error_message character varying(500) COLLATE pg_catalog."default",
    claim_id bigint,
    claimstatus character varying(2) COLLATE pg_catalog."default",
    claimtype character varying(20) COLLATE pg_catalog."default",
    sender_id character varying(100) COLLATE pg_catalog."default",
    receiverid character varying(100) COLLATE pg_catalog."default",
    processorcontrolnumber character varying(100) COLLATE pg_catalog."default",
    binnumber character varying(100) COLLATE pg_catalog."default",
    historicalindicator character varying(5) COLLATE pg_catalog."default",
    historicaldispositionstatus character varying(20) COLLATE pg_catalog."default",
    historicalencountericn character varying(50) COLLATE pg_catalog."default",
    historicalencounterid character varying(50) COLLATE pg_catalog."default",
    administrativedenial character varying(10) COLLATE pg_catalog."default",
    source character varying(100) COLLATE pg_catalog."default",
    claim_encounter_cleanup character varying(100) COLLATE pg_catalog."default",
    filler character varying(100) COLLATE pg_catalog."default",
    submitterlastname character varying(100) COLLATE pg_catalog."default",
    submitterid character varying(100) COLLATE pg_catalog."default",
    submittercontactname character varying(10) COLLATE pg_catalog."default",
    submittercontactnumberqual character varying(2) COLLATE pg_catalog."default",
    submittercontactnumber character varying(20) COLLATE pg_catalog."default",
    submittercontactemailqual character varying(2) COLLATE pg_catalog."default",
    submittercontactemail character varying(100) COLLATE pg_catalog."default",
    receivername character varying(100) COLLATE pg_catalog."default",
    receiverreceiveridentifierqual character varying(2) COLLATE pg_catalog."default",
    receiverreceiveridentifier character varying(100) COLLATE pg_catalog."default",
    billingorg_lastname character varying(100) COLLATE pg_catalog."default",
    billingfirstname character varying(100) COLLATE pg_catalog."default",
    serviceprovideridqual character varying(2) COLLATE pg_catalog."default",
    serviceproviderid character varying(15) COLLATE pg_catalog."default",
    placeofservice character varying(2) COLLATE pg_catalog."default",
    pharmacydispensertypequal character varying(1) COLLATE pg_catalog."default",
    pharmacydispensertype character varying(2) COLLATE pg_catalog."default",
    pharmacyclasscodequal character varying(1) COLLATE pg_catalog."default",
    pharmacyclasscode character varying(1) COLLATE pg_catalog."default",
    innetworkindicator character varying(1) COLLATE pg_catalog."default",
    networkreimbursementid character varying(10) COLLATE pg_catalog."default",
    billingaddressline1 character varying(100) COLLATE pg_catalog."default",
    billingaddressline2 character varying(100) COLLATE pg_catalog."default",
    billingcity character varying(100) COLLATE pg_catalog."default",
    billingstate character varying(100) COLLATE pg_catalog."default",
    billingpostalcode character varying(10) COLLATE pg_catalog."default",
    billingcountry character varying(100) COLLATE pg_catalog."default",
    billingprovideridqual_1 character varying(2) COLLATE pg_catalog."default",
    billingproviderid_1 character varying(100) COLLATE pg_catalog."default",
    billingprovideridqual_2 character varying(2) COLLATE pg_catalog."default",
    billingproviderid_2 character varying(100) COLLATE pg_catalog."default",
    billingproviderspeciality character varying(100) COLLATE pg_catalog."default",
    billingprovidertype character varying(100) COLLATE pg_catalog."default",
    billingprovidercommnoqual_1 character varying(3) COLLATE pg_catalog."default",
    billingprovidercommno_1 character varying(20) COLLATE pg_catalog."default",
    billingprovidercommnoqual_2 character varying(3) COLLATE pg_catalog."default",
    billingprovidercommno_2 character varying(20) COLLATE pg_catalog."default",
    facilityid character varying(20) COLLATE pg_catalog."default",
    serviceproviderchaincode character varying(10) COLLATE pg_catalog."default",
    cmspartddefinedqualfacility character varying(1) COLLATE pg_catalog."default",
    billingcountycode character varying(50) COLLATE pg_catalog."default",
    issuerid character varying(50) COLLATE pg_catalog."default",
    filler_2 character varying(50) COLLATE pg_catalog."default",
    filler_3 character varying(50) COLLATE pg_catalog."default",
    filler_4 character varying(50) COLLATE pg_catalog."default",
    filler_5 character varying(100) COLLATE pg_catalog."default",
    monetaryamountchangeflag character varying(2) COLLATE pg_catalog."default",
    claimsequencenumber character varying(20) COLLATE pg_catalog."default",
    CONSTRAINT stg_mep_claim_10r_pkey PRIMARY KEY (stg_mep_claim_10r_id, created)
) PARTITION BY RANGE (created);



ALTER TABLE IF EXISTS mepstg.stg_mep_claim_10r
    OWNER to deployadmin;

REVOKE ALL ON TABLE mepstg.stg_mep_claim_10r FROM mepinfauser_role;
REVOKE ALL ON TABLE mepstg.stg_mep_claim_10r FROM mepstg_query_role;
REVOKE ALL ON TABLE mepstg.stg_mep_claim_10r FROM mepstg_update_role;

GRANT ALL ON TABLE mepstg.stg_mep_claim_10r TO deployadmin;

GRANT ALL ON TABLE mepstg.stg_mep_claim_10r TO dwdba;

GRANT ALL ON TABLE mepstg.stg_mep_claim_10r TO dwdba_role;

GRANT ALL ON TABLE mepstg.stg_mep_claim_10r TO mepdevuser_role;

GRANT UPDATE, DELETE, INSERT, SELECT ON TABLE mepstg.stg_mep_claim_10r TO mepinfauser_role;

GRANT SELECT ON TABLE mepstg.stg_mep_claim_10r TO mepstg_query_role;

GRANT INSERT, SELECT, UPDATE ON TABLE mepstg.stg_mep_claim_10r TO mepstg_update_role;

COMMENT ON COLUMN mepstg.stg_mep_claim_10r.created_by
    IS 'The person or process that created the row on the database.';

COMMENT ON COLUMN mepstg.stg_mep_claim_10r.entered_by
    IS 'The person or process that created or last updated this row on the database.';


CREATE UNIQUE INDEX IF NOT EXISTS pk_stg_mep_claim_10r
    ON mepstg.stg_mep_claim_10r USING btree
    (stg_mep_claim_10r_id ASC NULLS LAST, created ASC NULLS LAST);


CREATE INDEX IF NOT EXISTS stg_mep_claim_10r_n1
    ON mepstg.stg_mep_claim_10r USING btree
    (stg_mep_claim_file_id ASC NULLS LAST, claim_id ASC NULLS LAST);


SELECT partman.create_parent( p_parent_table => 'mepstg.stg_mep_claim_10r',
 p_control => 'created',
 p_type => 'range',
 p_interval=> '1 week',
 p_start_partition=> '2023-08-06',
 p_premake => 4);

INSERT INTO mepstg.stg_mep_claim_10r SELECT * FROM mepstg.stg_mep_claim_10r_old;


UPDATE partman.part_config 
SET infinite_time_partitions=true,
retention='4 week',
retention_schema='archive_schema',
retention_keep_table=true, 
retention_keep_index=true 
WHERE parent_table='mepstg.stg_mep_claim_10r' ;


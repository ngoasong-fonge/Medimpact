
PTDEST=/tmp/pt/collected/$(pv2medpg1c1)

(youtube) https://www.youtube.com/watch?v=Ihh4xRCSotI, https://www.youtube.com/watch?v=SnrkMYbrS3E&t=906s

export PATH=$PATH:/usr/pgsql-10/bin

*****
CREATE EXTENSION pg_prewarm;

SELECT pg_prewarm('public.mytable'); (for table cashing to improve query peformance)


**check database size**
SELECT datname, (pg_stat_file('base/'||oid||'/PG_VERSION')).modification AS datcreated, pg_size_pretty(pg_database_size(datname))
FROM pg_database
WHERE datname LIKE 'TIMS%'
ORDER BY pg_database_size(datname);

** identify the tables that need vacuuming or to see dead turples
SELECT n_tup_ins as "inserts",n_tup_upd as "updates",n_tup_del as "deletes", n_live_tup as "live_tuples", n_dead_tup as "dead_tuples"
FROM pg_stat_user_tables
WHERE schemaname = 'ngmep' and relname = 'encounter_version';

SELECT relname, n_tup_ins as "inserts",n_tup_upd as "updates",n_tup_del as "deletes", n_live_tup as "live_tuples",n_dead_tup as "dead_tuples" FROM pg_stat_user_tables WHERE schemaname = 'xray' and n_dead_tup > 0 ;

** for all tables in a schema

SELECT relname, n_tup_ins as "inserts",n_tup_upd as "updates",n_tup_del as "deletes", n_live_tup as "live_tuples", n_dead_tup as "dead_tuples"
FROM pg_stat_user_tables
WHERE schemaname = 'smartiq';


show max_connections;
SELECT count(*), state FROM pg_stat_activity GROUP BY 2;
SELECT datname db, pid, usename who, application_name app, query_start starting_time, now()-query_start duration FROM pg_stat_activity WHERE  pid <> pg_backend_pid() ORDER BY 6 DESC; 
SELECT datname db, pid, usename who, application_name app, client_addr, client_hostname from pg_stat_activity;  (mobi matrics)

(to count pg_stat_activity)
select count(*) from pg_stat_activity;

(to know the name of the pid)
SELECT * FROM pg_stat_activity psa WHERE pid = '2843168'; 

(kills read transactions running longer than five minutes:)
SELECT
   pg_terminate_backend(pid) 
FROM pg_stat_activity
WHERE (now() - pg_stat_activity.query_start) > interval '5 minutes';

(to kill idle con) 
SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE pid <> pg_backend_pid() AND state = 'idle' AND state_change < current_timestamp - INTERVAL '0' MINUTE;

(queries longer than one minute)
SELECT pid, usename AS user, client_addr AS host, datname AS database, now() - xact_start AS txn_time, state, wait_event IS NOT NULL AS wait, query FROM pg_stat_activity WHERE now() - xact_start > '1 min' ORDER BY extract(epoch from (now() - backend_start)) DESC;

(CPU monitoring) 
select query,cpu_user_time, cpu_sys_time from pg_stat_monitor order by bucket_start_time desc limit 3;

(Error logging:)
select query, decode_error_level(elevel), sqlcode, message, state from pg_stat_monitor where message is not null order by bucket_start_time desc limit 5;

(Logging actual query:)
** alter system SET pg_stat_monitor.pgsm_normalized_query=off;
select datname, client_ip, application_name, query from pg_stat_monitor order by bucket_start_time desc limit 5;

(Query plan:)

** alter system SET pg_stat_monitor.pgsm_enable_query_plan=on;
select query, query_plan from pg_stat_monitor where query_plan is not null limit 2;

** setting statement_timeout **(A statement timeout will automatically kill queries that run longer than the allotted time)**
show statement_timeout;
alter database dbnamehere set statement_timeout = 60000; (which is 60 seconds at database level)
set statment_timeout = 6000000; (at session level)
ALTER ROLE mobijob SET statement_timeout=200000;
ALTER ROLE mobi SET idle_in_transaction_session_timeout TO 100000;
ALTER ROLE mobijob SET statement_timeout=600000;  (200 sec)
ALTER ROLE mobijob SET idle_in_transaction_session_timeout TO 100000; 
ALTER ROLE mobi SET statement_timeout=100000;   (100 sec)
ALTER ROLE tangoeqbr SET statement_timeout=0;

ALTER USER svcmepinfauser SET statement_timeout = 14400;

SELECT pg_user.usename, useconfig FROM pg_user WHERE username = svcmepinfauser ;
SELECT rolename, rolstatementtimeout FROM pg_roles WHERE rolname = svcmepinfauser;

(killing or cancelling a session or locks)
select pg_cancel_backend(pid); or (this cancels current query)
select pg_terminate_backend(4035058); (this kills the backend completely, so should be used for idle or idle in transaction backends)

**SELECT * FROM pg_stat_activity WHERE state = 'active';       2838089
SELECT count(*) FROM pg_stat_activity WHERE state = 'idle';
SELECT count(*) FROM pg_stat_activity WHERE state = 'active' AND username = 'svcmrguser';
 

**LOCKS**
(to see number of locks)
SELECT count(1) FROM pg_locks l RIGHT JOIN pg_database d ON (d.oid=l.database) WHERE d.datallowconn;
SELECT count(1) from pg_locks;
select * from pg_stat_activity;
select * from pg_locks; or
SELECT pl.pid, mode, query_start FROM pg_locks pl INNER JOIN pg_stat_activity psa ON pl.pid = psa.pid WHERE pl.mode = 'ExclusiveLock' AND state = 'active' ORDER BY query_start;

(check if a query is waiting for another query) \x
SELECT datname, usename, wait_event_type, wait_event, query FROM pg_stat_activity WHERE wait_event_type IS NOT NULL AND wait_event_type NOT IN ('Activity', 'Client');
or
SELECT * FROM pg_stat_activity WHERE wait_event IS NOT NULL;

(knowing who is blocking a query)\x
SELECT datname, usename, wait_event_type, wait_event, pg_blocking_pids(pid) AS blocked_by, query FROM pg_stat_activity WHERE wait_event_type IS NOT NULL AND wait_event_type NOT IN ('Activity', 'client');

(show block query and blocking queries)

SELECT a.pid AS blocked_pid, a.client_addr AS blocked_client, a.usename AS blocked_user, a.state AS blocked_state, a.wait_event AS blocked_event, a.query AS blocked_query, b.pid AS blocking_pid, b.client_addr AS blocking_client, b.usename AS blocking_user, b.state AS blocking_state, b.wait_event AS blocking_event, b.query AS blocking_query, now() - a.xact_start AS blocked_xact_duration, now() - a.state_change AS blocked_query_duration, now() - b.xact_start AS blocking_xact_duration, now() - b.state_change AS blocking_query_duration FROM pg_stat_activity a JOIN pg_stat_activity b ON (b.pid = ANY(pg_blocking_pids(a.pid))) WHERE a.state != 'idle' ORDER BY blocked_xact_duration DESC, blocked_query_duration DESC; 

( check health of replication_slotS) 
select * from pg_replication_slots; 

(check replication_slot lag)
select slot_name, pg_size_pretty(pg_xlog_location_diff(pg_current_xlog_location(),restart_lsn)) as replicationSlotLag, active from pg_replication_slots;


( to check a replication_lag conflict)
select * from pg_is_in_recovery();   If pg_is_in_recovery() returns true then there is a possible conflict


(checking replication)
select client_addr, state, sent_location, write_location, flush_location, replay_location from pg_stat_replication;
or select * from pg_stat_replication;

(check wal received or streaming replication)
select * from pg_stat_wal_receiver;

(check replication delay)
select now() - pg_last_xact_replay_timestamp() AS replication_delay;

( to check replication lag in seconds)
SELECT extract(seconds from (now() - pg_last_xact_replay_timestamp()))
AS time_lag;
OR
SELECT CASE WHEN pg_last_xlog_receive_location() =
pg_last_xlog_replay_location() THEN 0 ELSE EXTRACT (EPOCH FROM now() -
pg_last_xact_replay_timestamp()) END AS log_delay;


*** Command to compare parameters in an instance

select
  name as "Parameter",
  case when setting in ('-1', '0', 'off', 'on') then setting else
    case unit
      when '8kB' then pg_size_pretty(setting::int8 * 8 * 1024)
      when '16MB' then pg_size_pretty(setting::int8 * 16 * 1024 * 1024)
      when 'kB' then pg_size_pretty(setting::int8 * 1024)
      else setting || coalesce ('', ' ' || unit)
    end
  end as "Value",
  case when boot_val in ('-1', '0', 'off', 'on') then boot_val else
    case unit
      when '8kB' then pg_size_pretty(boot_val::int8 * 8 * 1024)
      when '16MB' then pg_size_pretty(boot_val::int8 * 16 * 1024 * 1024)
      when 'kB' then pg_size_pretty(boot_val::int8 * 1024)
      else boot_val || coalesce ('', ' ' || unit)
    end
  end as "Default",
  category as "Category"
from pg_settings
where
  name in (
    'max_connections',
    'shared_buffers',
    'effective_cache_size',
    'maintenance_work_mem',
    'work_mem',
    'min_wal_size',
    'max_wal_size',
    'checkpoint_completion_target',
    'wal_buffers',
    'default_statistics_target',
    'random_page_cost',
    'effective_io_concurrency',
    'max_worker_processes',
    'max_parallel_workers_per_gather',
    'log_destination',
    'logging_collector',
    'log_directory',
    'log_filename',
    'log_truncate_on_rotation',
    'log_rotation_age',
    'log_rotation_size',
    'log_min_duration_statement',
    'log_statement',
    'max_parallel_workers',
    'autovacuum',
    'autovacuum_max_workers',
    'autovacuum_vacuum_scale_factor',
    'autovacuum_vacuum_threshold', 
    'autovacuum_naptime',
    'max_replication_slots',
    'random_page_cost',
    'checkpoint_timeout'
    'seq_page_cost'
  )
order by category, name;



Functions to Control Streaming Replication replay:
 New version of PostgreSQL has New Streaming Replication Control Function. Information on it is given below:

a. pg_xlog_replay_pause(): 
Using this function user can pause recovery of Standby and would be able to take consistent backup of Standby Data Directory.
Example is given below:
postgres=# select  pg_xlog_replay_pause();
 pg_xlog_replay_pause 
----------------------
 
(1 row)
b. pg_is_xlog_replay_paused():
 Using this function user would be able to check the Standby/Streaming Replication is paused or not. Example is given below:
 postgres=# select  pg_is_xlog_replay_paused();
 pg_is_xlog_replay_paused 
--------------------------
 t
(1 row)
c. pg_xlog_replay_resume():
 Using this function user would be able resume replication of standby/streaming replication, if its recovery/replay is paused. Example is given below:
postgres=# select pg_xlog_replay_resume();
 pg_xlog_replay_resume 
-----------------------
 
(1 row)

postgres=# select  pg_is_xlog_replay_paused();
 pg_is_xlog_replay_paused 
--------------------------
 f

















(to query idle con) 
SELECT count(*) FROM pg_stat_activity WHERE pid <> pg_backend_pid() AND state ='idle' AND state_change < current_timestamp - INTERVAL '10' MINUTE;

(to kill idle con) 
SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE pid <> pg_backend_pid() AND state = 'idle' AND state_change < current_timestamp - INTERVAL '5' MINUTE;

(to see tuples) 
SELECT schemaname, relname, n_live_tup, n_dead_tup, last_autoanalyze, last_autovacuum FROM pg_stat_all_tables ORDER BY last_autovacuum DESC NULLS LAST;

CREATE INDEX idx_rpa_robot_message_log 
ON rpa_robot_message_log(message);

CREATE INDEX rpa_activities_log_lastextracted_idx
ON rpa_activities_log(lastextracted);

CREATE INDEX rpa_tracking_requests_xml_idx
ON rpa_tracking_requests_xml(activity_id, request_type);

** (to get a good view of query) \x

**( to show longest query duration in desc )**
SELECT datname db, pid, usename who, application_name app, query_start starting_time, now()-query_start duration FROM pg_stat_activity WHERE  pid <> pg_backend_pid() ORDER BY 6 DESC;
**SELECT current_timestamp-query_start, datname db, pid, query from pg_stat_activity where state = 'idle';

**(5 slowest querry)** \x
SELECT * FROM ( select current_timestamp-query_start "duration", query from pg_stat_activity where state = 'active' ) as temp order by "duration" desc limit 5;  
(longest quesries)\x
SELECT current_timestamp - query_start AS runtime, datname, usename, query FROM pg_stat_activity WHERE state = 'active' ORDER BY 2 DESC;

(running for morethan 1 min)\x
SELECT current_timestamp - query_start AS runtime, datname, usename, query FROM pg_stat_activity WHERE state = 'active' AND current_timestamp - query_start > '1 min' ORDER BY 1 DESC;

(check if a query is waiting for another query) \x
SELECT datname, usename, wait_event_type, wait_event, query FROM pg_stat_activity WHERE wait_event_type IS NOT NULL AND wait_event_type NOT IN ('Activity', 'Client');
or
SELECT * FROM pg_stat_activity WHERE wait_event IS NOT NULL;

(knowing who is blocking a query)\x
SELECT datname, usename, wait_event_type, wait_event, pg_blocking_pids(pid) AS blocked_by, query FROM pg_stat_activity WHERE wait_event_type IS NOT NULL AND wait_event_type NOT IN ('Activity', 'client');

(to know the name of the pid)
SELECT * FROM pg_stat_activity psa WHERE pid = '31526';

** setting statement_timeout**(A statement timeout will automatically kill queries that run longer than the allotted time)**
show statement_timeout;
alter database dbnamehere set statement_timeout = 60000; (which is 60 seconds at database level)
set statment_timeout = 6000000; (at session level)
ALTER ROLE mobijob SET statement_timeout=20000;
ALTER ROLE mobi SET idle_in_transaction_session_timeout TO 10000;

(killing idle in-transaction queries)(for more than 10mins)
SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE state = 'idle in transaction' AND current_timestamp - query_start > '10 min';

(to check if a particular query is bloated)
SELECT n_live_tup, n_dead_tup from pg_stat_user_tables where relname = ‘mytable’(replace 'mytable' with ur tablename);

**If issue persist check logs**

** How to show tables with more size in desc order or find out which tables are consuming the most disk space**

SELECT nspname || '.' || relname AS "relation",
    pg_size_pretty(pg_total_relation_size(C.oid)) AS "total_size"
  FROM pg_class C
  LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace)
  WHERE nspname NOT IN ('pg_catalog', 'information_schema')
    AND C.relkind <> 'i'
    AND nspname !~ '^pg_toast'
  ORDER BY pg_total_relation_size(C.oid) DESC
  LIMIT 70;

** To see size of table in a particular schema 
\q

** See tables with high transactionID ***

SELECT n.nspname AS schema_name
    , c.relname AS table_name
    , age(c.relfrozenxid) AS frozen_transaction_age
    , pg_size_pretty(pg_total_relation_size(c.oid)) AS table_size
FROM pg_class c
JOIN pg_namespace n on c.relnamespace = n.oid
WHERE relkind IN ('r', 't', 'm')
AND n.nspname NOT IN ('pg_toast')
ORDER BY frozen_transaction_age DESC
LIMIT 100;
**Bloat queries**

SELECT
  current_database(), schemaname, tablename, /*reltuples::bigint, relpages::bigint, otta,*/
  ROUND((CASE WHEN otta=0 THEN 0.0 ELSE sml.relpages::FLOAT/otta END)::NUMERIC,1) AS tbloat,
  CASE WHEN relpages < otta THEN 0 ELSE bs*(sml.relpages-otta)::BIGINT END AS wastedbytes,
  iname, /*ituples::bigint, ipages::bigint, iotta,*/
  ROUND((CASE WHEN iotta=0 OR ipages=0 THEN 0.0 ELSE ipages::FLOAT/iotta END)::NUMERIC,1) AS ibloat,
  CASE WHEN ipages < iotta THEN 0 ELSE bs*(ipages-iotta) END AS wastedibytes
FROM (
  SELECT
    schemaname, tablename, cc.reltuples, cc.relpages, bs,
    CEIL((cc.reltuples*((datahdr+ma-
      (CASE WHEN datahdr%ma=0 THEN ma ELSE datahdr%ma END))+nullhdr2+4))/(bs-20::FLOAT)) AS otta,
    COALESCE(c2.relname,'?') AS iname, COALESCE(c2.reltuples,0) AS ituples, COALESCE(c2.relpages,0) AS ipages,
    COALESCE(CEIL((c2.reltuples*(datahdr-12))/(bs-20::FLOAT)),0) AS iotta -- very rough approximation, assumes all cols
  FROM (
    SELECT
      ma,bs,schemaname,tablename,
      (datawidth+(hdr+ma-(CASE WHEN hdr%ma=0 THEN ma ELSE hdr%ma END)))::NUMERIC AS datahdr,
      (maxfracsum*(nullhdr+ma-(CASE WHEN nullhdr%ma=0 THEN ma ELSE nullhdr%ma END))) AS nullhdr2
    FROM (
      SELECT
        schemaname, tablename, hdr, ma, bs,
        SUM((1-null_frac)*avg_width) AS datawidth,
        MAX(null_frac) AS maxfracsum,
        hdr+(
          SELECT 1+COUNT(*)/8
          FROM pg_stats s2
          WHERE null_frac<>0 AND s2.schemaname = s.schemaname AND s2.tablename = s.tablename
        ) AS nullhdr
      FROM pg_stats s, (
        SELECT
          (SELECT current_setting('block_size')::NUMERIC) AS bs,
          CASE WHEN SUBSTRING(v,12,3) IN ('8.0','8.1','8.2') THEN 27 ELSE 23 END AS hdr,
          CASE WHEN v ~ 'mingw32' THEN 8 ELSE 4 END AS ma
        FROM (SELECT version() AS v) AS foo
      ) AS constants
      GROUP BY 1,2,3,4,5
    ) AS foo
  ) AS rs
  JOIN pg_class cc ON cc.relname = rs.tablename
  JOIN pg_namespace nn ON cc.relnamespace = nn.oid AND nn.nspname = rs.schemaname AND nn.nspname <> 'information_schema'
  LEFT JOIN pg_index i ON indrelid = cc.oid
  LEFT JOIN pg_class c2 ON c2.oid = i.indexrelid
) AS sml
ORDER BY wastedbytes DESC;

** OR/BEST QUERY **

WITH constants AS (

  SELECT current_setting('block_size')::numeric AS bs, 23 AS hdr, 4 AS ma

), bloat_info AS (

  SELECT

    ma,bs,schemaname,tablename,

    (datawidth+(hdr+ma-(case when hdr%ma=0 THEN ma ELSE hdr%ma END)))::numeric AS datahdr,

    (maxfracsum*(nullhdr+ma-(case when nullhdr%ma=0 THEN ma ELSE nullhdr%ma END))) AS nullhdr2

  FROM (

    SELECT

      schemaname, tablename, hdr, ma, bs,

      SUM((1-null_frac)*avg_width) AS datawidth,

      MAX(null_frac) AS maxfracsum,

      hdr+(

        SELECT 1+count(*)/8

        FROM pg_stats s2

        WHERE null_frac<>0 AND s2.schemaname = s.schemaname AND s2.tablename = s.tablename

      ) AS nullhdr

    FROM pg_stats s, constants

    GROUP BY 1,2,3,4,5

  ) AS foo

), table_bloat AS (

  SELECT

    schemaname, tablename, cc.relpages, bs,

    CEIL((cc.reltuples*((datahdr+ma-

      (CASE WHEN datahdr%ma=0 THEN ma ELSE datahdr%ma END))+nullhdr2+4))/(bs-20::float)) AS otta

  FROM bloat_info

  JOIN pg_class cc ON cc.relname = bloat_info.tablename

  JOIN pg_namespace nn ON cc.relnamespace = nn.oid AND nn.nspname = bloat_info.schemaname AND nn.nspname <> 'information_schema'

), index_bloat AS (

  SELECT

    schemaname, tablename, bs,

    COALESCE(c2.relname,'?') AS iname, COALESCE(c2.reltuples,0) AS ituples, COALESCE(c2.relpages,0) AS ipages,

    COALESCE(CEIL((c2.reltuples*(datahdr-12))/(bs-20::float)),0) AS iotta -- very rough approximation, assumes all cols

  FROM bloat_info

  JOIN pg_class cc ON cc.relname = bloat_info.tablename

  JOIN pg_namespace nn ON cc.relnamespace = nn.oid AND nn.nspname = bloat_info.schemaname AND nn.nspname <> 'information_schema'

  JOIN pg_index i ON indrelid = cc.oid

  JOIN pg_class c2 ON c2.oid = i.indexrelid

)

SELECT

  type, schemaname, object_name, bloat, pg_size_pretty(raw_waste) as waste

FROM

(SELECT

  'table' as type,

  schemaname,

  tablename as object_name,

  ROUND(CASE WHEN otta=0 THEN 0.0 ELSE table_bloat.relpages/otta::numeric END,1) AS bloat,

  CASE WHEN relpages < otta THEN '0' ELSE (bs*(table_bloat.relpages-otta)::bigint)::bigint END AS raw_waste

FROM

  table_bloat

    UNION

SELECT

  'index' as type,

  schemaname,

  tablename || '::' || iname as object_name,

  ROUND(CASE WHEN iotta=0 OR ipages=0 THEN 0.0 ELSE ipages/iotta::numeric END,1) AS bloat,

  CASE WHEN ipages < iotta THEN '0' ELSE (bs*(ipages-iotta))::bigint END AS raw_waste

FROM

  index_bloat) bloat_summary

ORDER BY raw_waste DESC, bloat DESC;

------------------------------------------------------------------------------------------------------------------------------------------------------------                                                           Mit. Script.
SELECT * FROM pg_stat_activity WHERE usename = 'kirk.roybal';
\connect mobi
SELECT table_name, reltuples, (sum(reltuples) OVER (ORDER BY table_name RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW))::bigint FROM information_schema.t
ables t INNER JOIN pg_class c ON t.table_name = c.relname WHERE table_type = 'BASE TABLE' and table_schema = 'public';
\q
\connect mobi
\dt	
SELECT * FROM corruption_log;
\q
SELECT * FROM pg_stat_activity WHERE usename = 'kirk.roybal';
\q
SELECT * FROM pg_stat_activity WHERE usename = 'kirk.roybal';
\q
SELECT * FROM corruption_log;
\connect mobi
SELECT * FROM corruption_log;
\q
select client_addr, state, sent_location, write_location,        flush_location, replay_location from pg_stat_replication;
\q
SELECT * FROM pg_stat_activity;
SELECT set_config('autovacuum', 'off'', false);SELECT pg_reload_conf();SELECT * FROM pg_stat_activity;SELECT * FROM pg_stat_activity ;';);
SELECT set_config('autovacuum', 'off', false);
\q
SELECT * FROM pg_stat_activity ;
\q
SELECT * FROM pg_stat_activity ;
\q
SELECT * FROM pg_stat_activity ;
\q
SELECT * FROM pg_stat_activity ;
select client_addr, state, sent_location, write_location,        flush_location, replay_location from pg_stat_replication;
SELECT * FROM pg_locks ;
SELECT * FROM pg_locks ;
SELECT * FROM pg_stat_activity ;
\q
**SELECT pl.pid, mode, query_start FROM pg_locks pl INNER JOIN pg_stat_activity psa ON pl.pid = psa.pid WHERE pl.mode = 'ExclusiveLock' AND state = 'active' ORDER BY query_start;
\q
SELECT datname db, pid, usename who, application_name app, query_start starting_time, now()-query_start duration, query FROM pg_stat_activity WHERE state NOT IN ('idle', 'idle in transaction') AND pid <> pg_backend_pid() ORDER BY 7 DESC;

SELECT datname db, pid, usename who, application_name app, query_start starting_time, now()-query_start duration, query FROM pg_stat_activity WHERE  pid <> pg_backend_pid() ORDER BY 7 DESC;

SELECT datname db, pid, usename who, application_name app, query_start starting_time, now()-query_start duration, query FROM pg_stat_activity WHERE  pid <> pg_backend_pid() ORDER BY 6 DESC;
select client_addr, state, sent_location, write_location,        flush_location, replay_location from pg_stat_replication;
\q
SELECT * FROM pg_stat_archiver ;
\q
SELECT pg_stat_progress_vacuum;
SELECT relname, last_autovacuum FROM pg_stat_user_tables ORDER BY last_autovacuum DESC;
SELECT * from pg_stat_progress_vacuum ;

SELECT datname db, pid, usename who, application_name app, query_start starting_time, now()-query_start duration, query FROM pg_stat_activity WHERE  pid <> pg_backend_pid() ORDER BY 6 DESC;

SELECT datname db, pid, usename who, application_name app, query_start starting_time, now()-query_start duration, query FROM pg_stat_activity WHERE query ilike '%vacuum%' AND  pid <> pg_backend_pid() ORDER BY 6 DESC;
\q
SELECT * FROM pg_stat_activity WHERE pid = '114029';
SELECT * FROM pg_stat_activity WHERE pid = '114029';
SELECT * FROM pg_stat_activity ;
SELECT * FROM pg_stat_activity ;
SELECT pg_terminate_backend(18665);
SELECT * FROM pg_stat_activity WHERE pid = 18665;
SELECT * FROM pg_stat_activity WHERE pid = 18665;
SELECT pg_terminate_backend(18665);
SELECT * FROM pg_stat_activity WHERE pid = 18665;
SELECT * FROM pg_stat_activity WHERE pid = 18665;
\connect mobi
SELECT * FROM request_logs WHERE id = 10080777;
select client_addr, state, sent_location, write_location,        flush_location, replay_location from pg_stat_replication;
SELECT pg_is_xlog_replay_paused();
SELECT * FROM pg_locks ;
SELECT * FROM pg_locks WHERE mode != 'AccessShareLock';
SELECT pid, mode FROM pg_locks WHERE mode != 'AccessShareLock';
SELECT pl.pid, pl.mode, psa.query FROM pg_locks pl INNER JOIN pg_stat_activity psa ON pl.pid = psa.pid WHERE mode != 'AccessShareLock';
SELECT pl.pid, pl.mode, psa.query FROM pg_stat_activity psa INNER JOIN pg_locks pl ON  psa.pid = pl.pid WHERE pl.mode != 'AccessShareLock';
SELECT pl.pid, pl.mode, psa.query FROM pg_stat_activity psa INNER JOIN pg_locks pl ON  psa.pid = pl.pid WHERE pl.mode != 'AccessShareLock';
SELECT distinct pl.pid, pl.mode, psa.query FROM pg_stat_activity psa INNER JOIN pg_locks pl ON  psa.pid = pl.pid WHERE pl.mode != 'AccessShareLock';
SELECT distinct pl.pid, pl.mode, psa.query_start, psa.query FROM pg_stat_activity psa INNER JOIN pg_locks pl ON  psa.pid = pl.pid WHERE pl.mode != 'AccessSha
reLock';
SELECT distinct pl.pid, pl.mode, psa.query_start, psa.query FROM pg_stat_activity psa INNER JOIN pg_locks pl ON  psa.pid = pl.pid WHERE pl.mode != 'AccessSha
reLock' ORDER BY psa.query_start DESC;
\dt
\connect mobi
\dt
\dt
\q
\du
\q
SELECT table_name, reltuples, (sum(reltuples) OVER (ORDER BY table_name RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW))::bigint FROM information_schema.tables t INNER JOIN pg_class c ON t.table_name = c.relname WHERE table_type = 'BASE TABLE' and table_schema = 'public';
\connect mobi
SELECT table_name, reltuples, (sum(reltuples) OVER (ORDER BY table_name RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW))::bigint FROM information_schema.tables t INNER JOIN pg_class c ON t.table_name = c.relname WHERE table_type = 'BASE TABLE' and table_schema = 'public';
q
\q
\q
SELECT (SELECT count(id) FROM versions_copy)/(SELECT reltuples FROM pg_class WHERE oid='public.versions'::regclass)*100 ;
\w
\q
SELECT (SELECT count(id) FROM versions_copy)/(SELECT reltuples FROM pg_class WHERE oid='public.versions'::regclass)*100 ;
\connect mobi
SELECT (SELECT count(id) FROM versions_copy)/(SELECT reltuples FROM pg_class WHERE oid='public.versions'::regclass)*100 ;
select client_addr, state, sent_location, write_location,        flush_location, replay_location from pg_stat_replication;
\q
SELECT * FROM pg_replication_slots ;
select client_addr, state, sent_location, write_location,        flush_location, replay_location from pg_stat_replication;
\q
\connect mobi_new
\list
\dt
\q
\dt
\connect mobi
\dt
\dt+ versions
\dt+
\dt+
SELECT table_name, reltuples, (sum(reltuples) OVER (ORDER BY table_name RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW))::bigint FROM information_schema.t
ables t INNER JOIN pg_class c ON t.table_name = c.relname WHERE table_type = 'BASE TABLE' and table_schema = 'public';
\list
\connect mobi_20190407
SELECT table_name, reltuples, (sum(reltuples) OVER (ORDER BY table_name RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW))::bigint FROM information_schema.t
ables t INNER JOIN pg_class c ON t.table_name = c.relname WHERE table_type = 'BASE TABLE' and table_schema = 'public';
SELECT count(id) FROM activities;
\connect mobi
SELECT count(id) FROM activities;
SELECT count(id) FROM accessories_ref_devices;
SELECT count(*) FROM accessories_ref_devices;
\connect mobi_20190407
SELECT count(*) FROM accessories_ref_devices;
\q
\connect mobi
select count(id) from bill_charges;
analyze bill_charges;
select count(id) from bill_charges;
\di
\di
\q
SELECT * FROM pg_stat_activity ;
SELECT * FROM pg_stat_activity WHERE query ilike '%vacuum%';
\q
SELECT datname db, pid, usename who, application_name app, query_start starting_time, now()-query_start duration FROM pg_stat_activity WHERE  pid <> pg_backend_pid() ORDER BY 6 DESC;
\q
\connect mobi_20190407
\list
\dt
SELECT * FROM corruption_log;
SELECT distinct(oid)  FROM corruption_log;
\q
\connect mobi
SELECT table_name, reltuples, (sum(reltuples) OVER (ORDER BY table_name RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW))::bigint FROM information_schema.t
ables t INNER JOIN pg_class c ON t.table_name = c.relname WHERE table_type = 'BASE TABLE' and table_schema = 'public';
\q
SELECT datname db, pid, usename who, application_name app, query_start starting_time, now()-query_start duration, queryFROM pg_stat_activityWHERE state NOT IN ('idle', 'idle in transaction')AND pid <> pg_backend_pid()ORDER BY 7 DESC;

SELECT datname db, pid, usename who, application_name app, query_start starting_time, now()-query_start duration, queryFROM pg_stat_activityWHERE pid <> pg_backend_pid()ORDER BY 7 DESC;

SELECT datname db, pid, usename who, application_name app, query_start starting_time, now()-query_start duration, queryFROM pg_stat_activityWHERE pid <> pg_backend_pid()ORDER BY 6 DESC;

\q
SELECT datname db, pid, usename who, application_name app, query_start starting_time, now()-query_start duration, queryFROM pg_stat_activityWHERE state NOT IN ('idle', 'idle in transaction')AND pid <> pg_backend_pid()ORDER BY 7 DESC;

SELECT datname db, pid, usename who, application_name app, query_start starting_time, now()-query_start duration, queryFROM pg_stat_activityWHERE application_name like 'resque%'AND pid <> pg_backend_pid()ORDER BY 7 DESC;
\q
SELECT usename, datname, count(*) FROM pg_stat_activity ;
\q
\q
SHOW statement_timeout;
\q
ALTER ROLE mobijob SET statement_timeout=200000;
\q
\q
\connect mobi
SELECT current_database(), schemaname, tblname, bs*tblpages AS real_size,  (tblpages-est_tblpages)*bs AS extra_size,  CASE WHEN tblpages - est_tblpages > 0
  THEN 100 * (tblpages - est_tblpages)/tblpages::float    ELSE 0  END AS extra_ratio, fillfactor, (tblpages-est_tblpages_ff)*bs AS bloat_size,  CASE WHEN tbl
pages - est_tblpages_ff > 0    THEN 100 * (tblpages - est_tblpages_ff)/tblpages::float    ELSE 0  END AS bloat_ratio, is_na  -- , (pst).free_percent + (pst).
dead_tuple_percent AS real_fragFROM (  SELECT ceil( reltuples / ( (bs-page_hdr)/tpl_size ) ) + ceil( toasttuples / 4 ) AS est_tblpages,    ceil( reltuples /
( (bs-page_hdr)*fillfactor/(tpl_size*100) ) ) + ceil( toasttuples / 4 ) AS est_tblpages_ff,    tblpages, fillfactor, bs, tblid, schemaname, tblname, heappage
s, toastpages, is_na    -- , stattuple.pgstattuple(tblid) AS pst  FROM (    SELECT      ( 4 + tpl_hdr_size + tpl_data_size + (2*ma)        - CASE WHEN tpl_hd
r_size%ma = 0 THEN ma ELSE tpl_hdr_size%ma END        - CASE WHEN ceil(tpl_data_size)::int%ma = 0 THEN ma ELSE ceil(tpl_data_size)::int%ma END      ) AS tpl_
size, bs - page_hdr AS size_per_block, (heappages + toastpages) AS tblpages, heappages,      toastpages, reltuples, toasttuples, bs, page_hdr, tblid, scheman
ame, tblname, fillfactor, is_na    FROM (      SELECT        tbl.oid AS tblid, ns.nspname AS schemaname, tbl.relname AS tblname, tbl.reltuples,        tbl.re
lpages AS heappages, coalesce(toast.relpages, 0) AS toastpages,        coalesce(toast.reltuples, 0) AS toasttuples,        coalesce(substring(          array
_to_string(tbl.reloptions, ' ')          FROM '%fillfactor=#"__#"%' FOR '#')::smallint, 100) AS fillfactor,        current_setting('block_size')::numeric AS
bs,        CASE WHEN version()~'mingw32' OR version()~'64-bit|x86_64|ppc64|ia64|amd64' THEN 8 ELSE 4 END AS ma,        24 AS page_hdr,        23 + CASE WHEN
MAX(coalesce(null_frac,0)) > 0 THEN ( 7 + count(*) ) / 8 ELSE 0::int END          + CASE WHEN tbl.relhasoids THEN 4 ELSE 0 END AS tpl_hdr_size,        sum( (
1-coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024) ) AS tpl_data_size,        bool_or(att.atttypid = 'pg_catalog.name'::regtype) AS is_na      FROM pg
_attribute AS att        JOIN pg_class AS tbl ON att.attrelid = tbl.oid        JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace        JOIN pg_stats AS s
 ON s.schemaname=ns.nspname          AND s.tablename = tbl.relname AND s.inherited=false AND s.attname=att.attname        LEFT JOIN pg_class AS toast ON tbl.
reltoastrelid = toast.oid      WHERE att.attnum > 0 AND NOT att.attisdropped        AND tbl.relkind = 'r'      GROUP BY 1,2,3,4,5,6,7,8,9,10, tbl.relhasoids
     ORDER BY 2,3    ) AS s  ) AS s2) AS s3;
\q
SELECT * FROM pg_stat_activity ;
SELECT datname db, pid, usename who, application_name app, query_start starting_time, now()-query_start duration, queryFROM pg_stat_activityWHERE state NOT I
N ('idle', 'idle in transaction')AND pid <> pg_backend_pid()ORDER BY 7 DESC;
SELECT datname db, pid, usename who, application_name app, query_start starting_time, now()-query_start duration, queryFROM pg_stat_activityWHERE pid <> pg_b
ackend_pid()ORDER BY 7 DESC;
\connect mobi
select count(*) from businesses;
\dt mobi
\dt businesses
\d businesses
SELECT * businesses LIMIT 1;
SELECT * businesses LIMIT 1;
SELECT * FROM businesses LIMIT 1;
SELECT active FROM businesses LIMIT 1;
select count(*) from businesses WHERE active = 't';
\q
\connect mobi
\q
\q
ALTER ROLE mobi SET statement_timeout=100000;
\q
SELECT * FROM pg_stat_activity ;
\q
\connect mobi
\dt
select count(lines);
select count(id) from lines;
\q
\du
CREATE USER tangoeqbr;
\password tangoeqbr
\dr
\dt
\q
SELECT count(*) FROM pg_stat_activity ;
SELECT * FROM pg_stat_activity ;
SELECT * FROM pg_stat_activity WHERE state ilike '%idle%';
SELECT count(*) FROM pg_stat_activity WHERE state ilike '%idle%';
SELECT count(*) FROM pg_stat_activity ;
SELECT count(*) FROM pg_stat_activity WHERE state ilike '%idle%';
SELECT count(*) FROM pg_stat_activity WHERE state NOT ilike '%idle%';
SELECT count(*) FROM pg_stat_activity WHERE state ilike '%idle%';
SELECT count(*) FROM pg_stat_activity WHERE state NOT ilike '%idle%';
\q
\dt+
\list+
SELECT current_database(), nspname AS schemaname, tblname, idxname, bs*(relpages)::bigint AS real_size,  bs*(relpages-est_pages)::bigint AS extra_size,  100
* (relpages-est_pages)::float / relpages AS extra_ratio,  fillfactor, bs*(relpages-est_pages_ff) AS bloat_size,  100 * (relpages-est_pages_ff)::float / relpa
ges AS bloat_ratio,  is_na  -- , 100-(sub.pst).avg_leaf_density, est_pages, index_tuple_hdr_bm, maxalign, pagehdr, nulldatawidth, nulldatahdrwidth, sub.reltu
ples, sub.relpages -- (DEBUG INFO)FROM (  SELECT coalesce(1 +       ceil(reltuples/floor((bs-pageopqdata-pagehdr)/(4+nulldatahdrwidth)::float)), 0 -- ItemIdD
ata size + computed avg size of a tuple (nulldatahdrwidth)    ) AS est_pages,    coalesce(1 +       ceil(reltuples/floor((bs-pageopqdata-pagehdr)*fillfactor/
(100*(4+nulldatahdrwidth)::float))), 0    ) AS est_pages_ff,    bs, nspname, table_oid, tblname, idxname, relpages, fillfactor, is_na    -- , stattuple.pgsta
tindex(quote_ident(nspname)||'.'||quote_ident(idxname)) AS pst, index_tuple_hdr_bm, maxalign, pagehdr, nulldatawidth, nulldatahdrwidth, reltuples -- (DEBUG I
NFO)  FROM (    SELECT maxalign, bs, nspname, tblname, idxname, reltuples, relpages, relam, table_oid, fillfactor,      ( index_tuple_hdr_bm +          maxal
ign - CASE -- Add padding to the index tuple header to align on MAXALIGN            WHEN index_tuple_hdr_bm%maxalign = 0 THEN maxalign            ELSE index_
tuple_hdr_bm%maxalign          END        + nulldatawidth + maxalign - CASE -- Add padding to the data to align on MAXALIGN            WHEN nulldatawidth = 0
 THEN 0            WHEN nulldatawidth::integer%maxalign = 0 THEN maxalign            ELSE nulldatawidth::integer%maxalign          END      )::numeric AS nul
ldatahdrwidth, pagehdr, pageopqdata, is_na      -- , index_tuple_hdr_bm, nulldatawidth -- (DEBUG INFO)    FROM (      SELECT        i.nspname, i.tblname, i.i
dxname, i.reltuples, i.relpages, i.relam, a.attrelid AS table_oid,        current_setting('block_size')::numeric AS bs, fillfactor,        CASE -- MAXALIGN:
4 on 32bits, 8 on 64bits (and mingw32 ?)          WHEN version() ~ 'mingw32' OR version() ~ '64-bit|x86_64|ppc64|ia64|amd64' THEN 8          ELSE 4        EN
D AS maxalign,        /* per page header, fixed size: 20 for 7.X, 24 for others */        24 AS pagehdr,        /* per page btree opaque data */        16 AS
 pageopqdata,        /* per tuple header: add IndexAttributeBitMapData if some cols are null-able */        CASE WHEN max(coalesce(s.null_frac,0)) = 0
   THEN 2 -- IndexTupleData size          ELSE 2 + (( 32 + 8 - 1 ) / 8) -- IndexTupleData size + IndexAttributeBitMapData size ( max num filed per index + 8
- 1 /8)        END AS index_tuple_hdr_bm,        /* data len: we remove null values save space using it fractionnal part from stats */        sum( (1-coalesc
e(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) AS nulldatawidth,        max( CASE WHEN a.atttypid = 'pg_catalog.name'::regtype THEN 1 ELSE 0 END ) > 0 AS
is_na      FROM pg_attribute AS a        JOIN (          SELECT nspname, tbl.relname AS tblname, idx.relname AS idxname, idx.reltuples, idx.relpages, idx.rel
am,            indrelid, indexrelid, indkey::smallint[] AS attnum,            coalesce(substring(              array_to_string(idx.reloptions, ' ')
     from 'fillfactor=([0-9]+)')::smallint, 90) AS fillfactor          FROM pg_index            JOIN pg_class idx ON idx.oid=pg_index.indexrelid            J
OIN pg_class tbl ON tbl.oid=pg_index.indrelid            JOIN pg_namespace ON pg_namespace.oid = idx.relnamespace          WHERE pg_index.indisvalid AND tbl.
relkind = 'r' AND idx.relpages > 0        ) AS i ON a.attrelid = i.indexrelid        JOIN pg_stats AS s ON s.schemaname = i.nspname          AND ((s.tablenam
e = i.tblname AND s.attname = pg_catalog.pg_get_indexdef(a.attrelid, a.attnum, TRUE)) -- stats from tbl          OR   (s.tablename = i.idxname AND s.attname
= a.attname))-- stats from functionnal cols        JOIN pg_type AS t ON a.atttypid = t.oid      WHERE a.attnum > 0      GROUP BY 1, 2, 3, 4, 5, 6, 7, 8, 9
 ) AS s1  ) AS s2    JOIN pg_am am ON s2.relam = am.oid WHERE am.amname = 'btree') AS sub-- WHERE NOT is_naORDER BY 2,3,4;

SELECT current_database(), schemaname, tblname, bs*tblpages AS real_size,  (tblpages-est_tblpages)*bs AS extra_size,  CASE WHEN tblpages - est_tblpages > 0
  THEN 100 * (tblpages - est_tblpages)/tblpages::float    ELSE 0  END AS extra_ratio, fillfactor, (tblpages-est_tblpages_ff)*bs AS bloat_size,  CASE WHEN tbl
pages - est_tblpages_ff > 0    THEN 100 * (tblpages - est_tblpages_ff)/tblpages::float    ELSE 0  END AS bloat_ratio, is_na  -- , (pst).free_percent + (pst).
dead_tuple_percent AS real_fragFROM (  SELECT ceil( reltuples / ( (bs-page_hdr)/tpl_size ) ) + ceil( toasttuples / 4 ) AS est_tblpages,    ceil( reltuples /
( (bs-page_hdr)*fillfactor/(tpl_size*100) ) ) + ceil( toasttuples / 4 ) AS est_tblpages_ff,    tblpages, fillfactor, bs, tblid, schemaname, tblname, heappage
s, toastpages, is_na    -- , stattuple.pgstattuple(tblid) AS pst  FROM (    SELECT      ( 4 + tpl_hdr_size + tpl_data_size + (2*ma)        - CASE WHEN tpl_hd
r_size%ma = 0 THEN ma ELSE tpl_hdr_size%ma END        - CASE WHEN ceil(tpl_data_size)::int%ma = 0 THEN ma ELSE ceil(tpl_data_size)::int%ma END      ) AS tpl_
size, bs - page_hdr AS size_per_block, (heappages + toastpages) AS tblpages, heappages,      toastpages, reltuples, toasttuples, bs, page_hdr, tblid, scheman
ame, tblname, fillfactor, is_na    FROM (      SELECT        tbl.oid AS tblid, ns.nspname AS schemaname, tbl.relname AS tblname, tbl.reltuples,        tbl.re
lpages AS heappages, coalesce(toast.relpages, 0) AS toastpages,        coalesce(toast.reltuples, 0) AS toasttuples,        coalesce(substring(          array
_to_string(tbl.reloptions, ' ')          FROM '%fillfactor=#"__#"%' FOR '#')::smallint, 100) AS fillfactor,        current_setting('block_size')::numeric AS
bs,        CASE WHEN version()~'mingw32' OR version()~'64-bit|x86_64|ppc64|ia64|amd64' THEN 8 ELSE 4 END AS ma,        24 AS page_hdr,        23 + CASE WHEN
MAX(coalesce(null_frac,0)) > 0 THEN ( 7 + count(*) ) / 8 ELSE 0::int END          + CASE WHEN tbl.relhasoids THEN 4 ELSE 0 END AS tpl_hdr_size,        sum( (
1-coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024) ) AS tpl_data_size,        bool_or(att.atttypid = 'pg_catalog.name'::regtype) AS is_na      FROM pg
_attribute AS att        JOIN pg_class AS tbl ON att.attrelid = tbl.oid        JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace        JOIN pg_stats AS s
 ON s.schemaname=ns.nspname          AND s.tablename = tbl.relname AND s.inherited=false AND s.attname=att.attname        LEFT JOIN pg_class AS toast ON tbl.
reltoastrelid = toast.oid      WHERE att.attnum > 0 AND NOT att.attisdropped        AND tbl.relkind = 'r'      GROUP BY 1,2,3,4,5,6,7,8,9,10, tbl.relhasoids
     ORDER BY 2,3    ) AS s  ) AS s2) AS s3;

SELECT blocked_locks.pid AS blocked_pid,blocked_activity.usename AS blocked_user,blocked_activity.application_name AS blocking_app,blocked_activity.client_ho
stname AS blocking_client_hostname,blocking_locks.pid AS blocking_pid,blocking_activity.usename AS blocking_user,blocked_activity.query AS blocked_query,bloc
king_activity.query AS blocking_queryFROM  pg_catalog.pg_locks blocked_locksJOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = block
ed_locks.pidJOIN pg_catalog.pg_locks blocking_locksON blocking_locks.locktype = blocked_locks.locktypeAND blocking_locks.database IS NOT DISTINCT FROM blocke
d_locks.databaseAND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relationAND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.pageAND blo
cking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tupleAND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxidAND blocking_locks.trans
actionid IS NOT DISTINCT FROM blocked_locks.transactionidAND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classidAND blocking_locks.objid IS NOT
 DISTINCT FROM blocked_locks.objidAND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubidAND blocking_locks.pid != blocked_locks.pidJOIN pg_c
atalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pidWHERE NOT blocked_locks.granted;
WITH RECURSIVE    c(requested, CURRENT) AS       ( VALUES         ('AccessShareLock'::text, 'AccessExclusiveLock'::text),         ('RowShareLock'::text, 'Exc
lusiveLock'::text),         ('RowShareLock'::text, 'AccessExclusiveLock'::text),         ('RowExclusiveLock'::text, 'ShareLock'::text),         ('RowExclusiv
eLock'::text, 'ShareRowExclusiveLock'::text),         ('RowExclusiveLock'::text, 'ExclusiveLock'::text),         ('RowExclusiveLock'::text, 'AccessExclusiveL
ock'::text),         ('ShareUpdateExclusiveLock'::text, 'ShareUpdateExclusiveLock'::text),         ('ShareUpdateExclusiveLock'::text, 'ShareLock'::text),
     ('ShareUpdateExclusiveLock'::text, 'ShareRowExclusiveLock'::text),         ('ShareUpdateExclusiveLock'::text, 'ExclusiveLock'::text),         ('ShareUpd
ateExclusiveLock'::text, 'AccessExclusiveLock'::text),         ('ShareLock'::text, 'RowExclusiveLock'::text),         ('ShareLock'::text, 'ShareUpdateExclusi
veLock'::text),         ('ShareLock'::text, 'ShareRowExclusiveLock'::text),         ('ShareLock'::text, 'ExclusiveLock'::text),         ('ShareLock'::text, '
AccessExclusiveLock'::text),         ('ShareRowExclusiveLock'::text, 'RowExclusiveLock'::text),         ('ShareRowExclusiveLock'::text, 'ShareUpdateExclusive
Lock'::text),         ('ShareRowExclusiveLock'::text, 'ShareLock'::text),         ('ShareRowExclusiveLock'::text, 'ShareRowExclusiveLock'::text),         ('S
hareRowExclusiveLock'::text, 'ExclusiveLock'::text),         ('ShareRowExclusiveLock'::text, 'AccessExclusiveLock'::text),         ('ExclusiveLock'::text, 'R
owShareLock'::text),         ('ExclusiveLock'::text, 'RowExclusiveLock'::text),         ('ExclusiveLock'::text, 'ShareUpdateExclusiveLock'::text),         ('
ExclusiveLock'::text, 'ShareLock'::text),         ('ExclusiveLock'::text, 'ShareRowExclusiveLock'::text),         ('ExclusiveLock'::text, 'ExclusiveLock'::te
xt),         ('ExclusiveLock'::text, 'AccessExclusiveLock'::text),         ('AccessExclusiveLock'::text, 'AccessShareLock'::text),         ('AccessExclusiveL
ock'::text, 'RowShareLock'::text),         ('AccessExclusiveLock'::text, 'RowExclusiveLock'::text),         ('AccessExclusiveLock'::text, 'ShareUpdateExclusi
veLock'::text),         ('AccessExclusiveLock'::text, 'ShareLock'::text),         ('AccessExclusiveLock'::text, 'ShareRowExclusiveLock'::text),         ('Acc
essExclusiveLock'::text, 'ExclusiveLock'::text),         ('AccessExclusiveLock'::text, 'AccessExclusiveLock'::text)       ),     l AS       (         SELECT
            (locktype,DATABASE,relation::regclass::text,page,tuple,virtualxid,transactionid,classid,objid,objsubid) AS target,             virtualtransaction
,             pid,             mode,             GRANTED           FROM pg_catalog.pg_locks       ),     t AS       (         SELECT             blocker.targ
et  AS blocker_target,             blocker.pid     AS blocker_pid,             blocker.mode    AS blocker_mode,             blocked.target  AS target,
      blocked.pid     AS pid,             blocked.mode    AS mode           FROM l blocker           JOIN l blocked             ON ( NOT blocked.GRANTED
         AND blocker.GRANTED              AND blocked.pid != blocker.pid              AND blocked.target IS NOT DISTINCT FROM blocker.target)           JOIN
c ON (c.requested = blocked.mode AND c.CURRENT = blocker.mode)       ),     r AS       (         SELECT             blocker_target,             blocker_pid,
            blocker_mode,             '1'::INT        AS depth,             target,             pid,             mode,             blocker_pid::text || ',' |
| pid::text AS seq           FROM t         UNION ALL         SELECT             blocker.blocker_target,             blocker.blocker_pid,             blocker
.blocker_mode,             blocker.depth + 1,             blocked.target,             blocked.pid,             blocked.mode,             blocker.seq || ',' |
| blocked.pid::text           FROM r blocker           JOIN t blocked             ON (blocked.blocker_pid = blocker.pid)           WHERE blocker.depth < 1000
       )SELECT * FROM r  ORDER BY seq;

\q
SELECT * FROM pg_stat_database;
SELECT * FROM pg_stat_database;
\q
\du
\dr
\du
GRANT USAGE ON SCHEMA public TO tangoeqbr;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO tangoeqbr;
\connect mobi
GRANT USAGE ON SCHEMA public TO tangoeqbr;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO tangoeqbr;
SET ROLE tangoeqbr;
SELECT count(*) FROM devices;
\q
\q
select usename,datname,count(*) from pg_stat_activity group by usename,datname order by 3 desc;
select usename,datname,count(*) from pg_stat_activity group by usename,datname ;
select * from pg_stat_activity group by usename,datname ;
select usename,datname,* from pg_stat_activity group by usename,datname ;
select * from pg_stat_activity ;
\q
select client_addr, state, sent_location, write_location,        flush_location, replay_location from pg_stat_replication;
\q
SELECT * FROM pg_stat_activity ;
SELECT * FROM pg_stat_activity ;
SELECT * FROM pg_stat_activity WHERE state != 'idle';
SELECT * FROM pg_stat_activity WHERE state != 'idle';
SEELCT * FROM pg_locks ;
SELCT * FROM pg_locks ;
SELECT * FROM pg_locks ;
SELECT * FROM pg_locks pl INNER JOIN pg_stat_activity psa ON pl.pid = psa.pid WHERE pl.mode NOT ilike '%sharelock%';
SELECT * FROM pg_stat_activity ;
SELECT * FROM pg_stat_activity ;
SELECT * FROM pg_stat_activity ;
select pg_terminate_backend(46402);
SELECT * FROM pg_stat_activity ;
SELECT * FROM pg_stat_activity ;
\q
select client_addr, state, sent_location, write_location,        flush_location, replay_location from pg_stat_replication;
select client_addr, state, sent_location, write_location,        flush_location, replay_location from pg_stat_replication;
select client_addr, state, sent_location, write_location,        flush_location, replay_location from pg_stat_replication;
select client_addr, state, sent_location, write_location,        flush_location, replay_location from pg_stat_replication;
SELECT * FROM pg_statistic;
\connect mobi
SELECT * FROM pg_statistic;
\q
ALTER USER mobi SET statement_timeout = 0;
\q
SHOW statement_timeout mobi;
SHOW statement_timeout ;
SHOW USER mobi statement_timeout ;
ALTER USER mobi SET statement_timeout = 100000;
SELECT * FROM pg_locks LIMIT 1;
SELECT * FROM pg_locks pl INNER JOIN pg_stat_activity psa ON pl.pid = psa.pid WHERE pl.mode ilike '%exclusive%' LIMIT 1;
\q
CREATE USER "ngoasong.fonge" WITH superuser;
\password ngoasong.fonge
\du
\q
CREATE ROLE dbas WITH superuser;
GRANT dbas TO ngoasong.fonge;
GRANT dbas TO "ngoasong.fonge";
\du+
SELECT pg_reload_conf();
\q
SELECT * FROM pg_stat_activity ;
SELECT * FROM pg_locks ;
SELECT * FROM pg_locks pl INNER JOIN pg_stat_activity psa ON pl.pid = psa.pid WHERE pl.mode = 'ExclusiveLock';

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Kirk.roybal---------------------------------------------------------------------------------------------

SELECT * FROM corruption_log;
\q
SELECT * FROM corruption_log;
SELECT * FROM pg_stat_activity;
SELECT * FROM pg_stat_activity WHERE appname = 'psql' AND usename = 'kirk.roybal';
SELECT * FROM pg_stat_activity WHERE application_name = 'psql' AND usename = 'kirk.roybal';
SELECT * FROM pg_stat_activity WHERE application_name = 'psql' AND usename = 'kirk.roybal' AND pid <> pg_backend_pid();
SELECT query_start, query, now() - query_start duration, * FROM pg_stat_activity WHERE application_name = 'psql' AND usename = 'kirk.roybal' AND pid <> pg_ba
ckend_pid();
SELECT query_start, now() - query_start duration, * FROM pg_stat_activity WHERE application_name = 'psql' AND usename = 'kirk.roybal' AND pid <> pg_backend_p
id();
SELECT now() - query_start duration, xact_start, state_change, state, query FROM pg_stat_activity WHERE application_name = 'psql' AND usename = 'kirk.roybal'
 AND pid <> pg_backend_pid();
SELECT now() - query_start duration, xact_start, state_change, state, regexp_replace(query,'.*public.','','g') query FROM pg_stat_activity WHERE application_
name = 'psql' AND usename = 'kirk.roybal' AND pid <> pg_backend_pid();
SELECT now() - query_start duration, xact_start, now() - state_change last_changed, state, regexp_replace(query,'.*public.','','g') query FROM pg_stat_activi
ty WHERE application_name = 'psql' AND usename = 'kirk.roybal' AND pid <> pg_backend_pid();
SELECT now() - query_start duration, xact_start, now() - state_change last_changed, state, regexp_replace(query,'.*public.','','g') query FROM pg_stat_activi
ty WHERE application_name = 'psql' AND usename = 'kirk.roybal' AND pid <> pg_backend_pid();
SELECT now() - query_start duration, xact_start, now() - state_change last_changed, state, regexp_replace(query,'.*public.','','g') query FROM pg_stat_activi
ty WHERE application_name = 'psql' AND usename = 'kirk.roybal' AND pid <> pg_backend_pid();
SELECT now() - query_start duration, xact_start, now() - state_change last_changed, state, regexp_replace(query,'.*public.','','g') query FROM pg_stat_activi
ty WHERE application_name = 'psql' AND usename = 'kirk.roybal' AND pid <> pg_backend_pid();
SELECT now() - query_start duration, xact_start, now() - state_change last_changed, state, regexp_replace(query,'.*public.','','g') query FROM pg_stat_activi
ty WHERE application_name = 'psql' AND usename = 'kirk.roybal' AND pid <> pg_backend_pid();
SELECT now() - query_start duration, xact_start, now() - state_change last_changed, state, regexp_replace(query,'.*public.','','g') query FROM pg_stat_activi
ty WHERE application_name = 'psql' AND usename = 'kirk.roybal' AND pid <> pg_backend_pid();
\q

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ANALYTICSDB-------------------------------------------------------------------------------------

SELECT business_id from people WHERE email = 'mitchell.thompson@mobiwm.com';
SELECT id, email FROM people WHERE business_id = 1;
SELECT id, email FROM people WHERE business_id = 1 ORDER BY email;
\q
ALTER DATABASE mobi SET log_min_duration_statement = 0;
\q
\q
\list
\connect mobi
select * from activities limit 1;
SELECT * FROM people WHERE id = '3426936';
\list
\dt
SELECT * FROM people WHERE id = '3426936';
SELECT * FROM people WHERE single_access_token = 'hdTWKTh1g3eH2ILt1OJ';
SELECT * FROM people WHERE single_access_token = 'shdTWKTh1g3eH2ILt1OJ';
SELECT * FROM people WHERE id = '3426936';
\q
\list
\q
\list
\list+
\du
SET SESSION AUTHORIZATION pentaho_user;
\connect quartz
\dt
SELECT * FROM qrtz5_triggers;
\q
\list+
\du
SET SESSION AUTHROIZATION bking;
SET SESSION AUTHROIZATION TO bking;
wwSET SESSION AUTHORIZATION bking;
wwwSET SESSION AUTHORIZATION bking;
SET SESSION AUTHORIZATION bking;
\USE analytics_production;
\CONNECT analytics_production;
\connect analytics_production
RESET SESSION AUTHORIZATION;
SET SESSION AUTHORIZATION 'bking';
\list
\dt
SELECT * FROM management_configurations;
-------------------------------------------------Derick--------------------------------------------

GRANT "data_team_admin" TO "sahana.shivaprasad";
CREATE USER "craig.hicks";
CREATE USER "pamela.williams";
\password "pamela.williams"
GRANT "data_team_admin" TO "pamela.williams";
CREATE USER "jacob.mcgathey";
\password "jacob.mcgathey"
GRANT "data_team_admin" TO "jacob.mcgathey";
CREATE USER "iman.noureldin";
\password "iman.noureldin"
GRANT "data_team_admin" TO "iman.noureldin";
CREATE USER "archit.patel";
\password "archit.patel"
GRANT "data_team_admin" TO "archit.patel";
\q
\dp public
\du
\dn analytics_production+
\dn +
\dn+
\dp analytics_production
\q
\du
\dn+
\dp
\q
\du
\dp
GRANT "pentaho_analytics" TO "mark.bailey";
GRANT "pentaho_analytics" TO "mbailey";
\q
SHOW hba_file;
\q
\du
ALTER USER "zack.goldberg" CONNECTION LIMIT 10;
ALTER USER "sahana.shivaprasad" CONNECTION LIMIT 10;
ALTER USER "pamela.wiliams" CONNECTION LIMIT 10;
ALTER USER "pamela.williams" CONNECTION LIMIT 10;
ALTER USER "jacob.mcgathey" CONNECTION LIMIT 10;
ALTER USER "iman.noureldin" CONNECTION LIMIT 10;
ALTER USER "craig.hicks" CONNECTION LIMIT 10;
ALTER USER "archit.patel" CONNECTION LIMIT 10;
\list
DROP USER "amrutha.pulikottil";
DROP USER "contractor";
DROP USER "kapow";
DROP USER "kbassyouny";
DROP USER "kkennedy";
DROP USER "ndrake";
DROP USER "wedrington";
DROP USER "yliu";
SHOW max_connections;
\du
\q
\du
\dt
ALTER TABLE public.rpa_vzw_ecpd_tracking OWNER data_team;
ALTER TABLE public.rpa_vzw_ecpd_tracking OWNER "data_team";
ALTER TABLE public.rpa_vzw_ecpd_tracking OWNER TO data_team;
ALTER TABLE public.rpa_vzw_ecpd_mapping OWNER TO data_team;
\td
\dt
\q
ALTER TABLE public.rpa_fulfillment_system_rules OWNER TO data_team;
ALTER TABLE public.rpa_tracking_email_process_requests OWNER TO data_team;
\du
\q
CREATE USER "jerry.muncy";
\password "jerry.muncy"
GRANT data_team_admin TO "jerry.muncy";
ALTER USER "jerry.muncy" CONNECTION LIMIT 10;
\q
CREATE USER "ashton.knoblock";
\password "ashton.knoblock"
GRANT data_team_admin TO "ashton.knoblock";
ALTER USER "ashton.knoblock" CONNECTION LIMIT 10;
\q
\du
REVOKE pentaho_analytics FROM mbailey;
SELECT grantee, privilege_type FROM information_schema.role_table_grants WHERE grantee = 'team_lead';
SELECT grantee, privilege_type FROM information_schema.role_table_grants WHERE grantee = 'data_team_admin';
SELECT grantee, privilege_type FROM information_schema.role_table_grants;
SELECT * FROM information_schema.role_table_grants LIMIT 1;
SELECT grantee, table_name, privilege_type FROM information_schema.role_table_grants WHERE table_catalog = 'analytics_production';
SELECT grantee, table_name, privilege_type FROM information_schema.role_table_grants WHERE table_catalog = 'analytics_production' AND grantee != 'postgres';
SELECT grantee, table_name, privilege_type FROM information_schema.role_table_grants WHERE table_catalog = 'analytics_production' AND grantee != 'postgres' A
ND grantee != 'PUBLIC';
\q
\du
\dt
SELECT grantee, table_name, privilege_type FROM information_schema.role_table_grants WHERE table_catalog = 'analytics_production' AND grantee != 'postgres' A
ND grantee != 'PUBLIC';
SELECT grantee, table_name, privilege_type FROM information_schema.role_table_grants WHERE table_catalog = 'mobi_dw' AND grantee != 'postgres' AND grantee !=
 'PUBLIC';
SELECT grantee, table_name, privilege_type FROM information_schema.role_table_grants WHERE table_catalog = 'mobi_dw' AND grantee != 'postgres' AND grantee !=
 'PUBLIC' AND table_name = 'rpa_tracking_email_process_requests';
\du
SET ROLE cpfeiffer;
SELECT SESSION_USER, CURRENT_USER;
SELECT * FROM public.rpa_tracking_email_process_requests LIMIT 1;
SET ROLE data_team_admin;
SELECT * FROM public.rpa_tracking_email_process_requests LIMIT 1;
SET ROLE data_team;
SELECT * FROM public.rpa_tracking_email_process_requests LIMIT 1;
SET ROLE 'derik.taylor';
SELECT grantee, table_name, privilege_type FROM information_schema.role_table_grants WHERE table_catalog = 'mobi_dw' AND grantee != 'postgres' AND grantee !=
 'PUBLIC' AND table_name = 'rpa_tracking_email_process_requests';
SELECT grantee, table_name, privilege_type FROM information_schema.role_table_grants WHERE table_catalog = 'mobi_dw' AND grantee != 'postgres' AND grantee !=
 'PUBLIC' AND table_name = 'rpa_activity_facts';
GRANT INSERT, SELECT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER ON public.rpa_tracking_email_process_requests TO data_team_admin;
SET ROLE cpfeiffer;
SELECT * FROM public.rpa_tracking_email_process_requests LIMIT 1;
SET ROLE 'derik.taylor';
\q
\q
\du
\q
CREATE USER automation_fixed;
\password automation_fixed
\du
\l
\l
CREATE DATABASE "automation_fixed" WITH OWNER "automation_fixed";
ALTER DATABASE "automation_fixed" OWNER TO mobi;
\q
\l
\l
SELECT grantee, privilege_type FROM information_schema.role_table_grants WHERE grantee = 'kapow_mc';
SELECT grantee, privilege_type FROM information_schema.role_table_grants WHERE grantee = 'kapowmc';
SELECT * FROM information_schema.role_table_grants WHERE grantee = 'kapowmc';
SELECT * FROM information_schema.role_table_grants WHERE grantee = 'data_team';
SELECT * FROM information_schema.role_table_grants WHERE grantee = 'data_team' AND privilege_type = 'CONNECT';
GRANT ALL ON 'fixed_automation' TO 'fixed_automation';
GRANT ALL ON fixed_automation TO 'fixed_automation';
GRANT ALL ON fixed_automation TO fixed_automation;
\l
GRANT ALL ON automation_fixed TO automation_fixed;
\du
GRANT ALL ON DATABASE automation_fixed TO automation_fixed;
SELECT * FROM information_schema.role_table_grants WHERE grantee = 'automation_fixed';
SELECT * FROM information_schema.role_usage_grants WHERE grantee = 'automation_fixed';
GRANT data_team_admin TO "robert.rumple";
ALTER USER "robert.rumple" CONNECTION LIMIT 10;
\q
CREATE USER "matthew.scharnak";
\password "matthew.scharnak"
GRANT data_team_admin TO "matthew.scharnak";
ALTER USER "matthew.scharnak" CONNECTION LIMIT 10;
\q
\du
\q
SELECT pg_reload_conf();
DROP TABLE aut_execution_master;
DROP TABLE ent_account_look_up;
DROP TABLE ent_business_service;
DROP TABLE CASCADE ent_business_service;
DROP TABLE ent_business_service CASCADE;
\dt
DROP TABLE ent_platform;
DROP TABLE ent_platform CASCADE;
\dt
DROP TABLE ent_tenant;
DROP TABLE ent_tenant CASCADE;
\dt
DROP TABLE ent_tenant_business_service CASCADE;
DROP TABLE ent_vendor CASCADE;
DROP TABLE sys_database_changelog CASCADE;
\dt
DROP TABLE sys_system_config CASCADE;
DROP TABLE ent_vendor_access CASCADE;
\dt
\q
\dt
quit();
\q
select pg_reload_conf();
\dt
\q
GRANT SELECT ON public.carrier_line_details TO kapowmc;
GRANT SELECT ON public.management_jobs TO kapowmc;
GRANT SELECT ON public.management_configurations TO kapowmc;
GRANT SELECT ON public.portfolios TO kapowmc;
GRANT SELECT ON public.download_configurations TO kapowmc;
\q
select pg_reload_conf();
\q
GRANT SELECT ON public.download_jobs TO kapowmc;
\q
CREATE USER chase.mitchell;
CREATE USER 'chase.mitchell';
CREATE USER "chase.mitchell";
ALTER USER "chase.mitchell" SUPERUSER;
\password "chase.mitchell"













